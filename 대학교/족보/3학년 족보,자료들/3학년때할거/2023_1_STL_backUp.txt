

======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 10:39:42
======================================================

#include <iostream>
#include "save.h"
using namespace std;

void change(int& a, int& b);

//---------
int main()
//---------
{
	// [문제] main이 의도한대로 실행되게 필요한 코딩을 하라
	// main()이 수정되면 안됨

	int a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}

void change(int& a, int& b)
{
	int temp{ a };

	a = b;
	b = temp;
}

======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 10:43:32
======================================================

#include <iostream>
#include "save.h"
using namespace std;

class Dog {
	int n;
public:
	Dog(int n) : n{n} {}
	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << dog.n;
	}
};

void change(int&, int&);
void change(Dog&, Dog&);

//---------
int main()
//---------
{
	// [문제] main이 의도한대로 실행되게 필요한 코딩을 하라
	// main()이 수정되면 안됨

	Dog a{ 1 }, b{ 2 };

	change(a, b);

	cout << a << ", " << b << endl;

	save("소스.cpp");
}

void change(int& a, int& b)
{
	int temp{ a };
	a = b;
	b = temp;
}

void change(Dog& a, Dog& b)
{
	Dog temp{ a };
	a = b;
	b = temp;
}

======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 10:48:07
======================================================

#include <iostream>
#include <random>
#include <format>
#include "save.h"
using namespace std;

default_random_engine dre;
//---------
int main()
//---------
{
	// 랜덤 int 1000개를 생성해서 화면에 출력하라
	uniform_int_distribution<int> uid{ 0, 999'999'999 };

	for (int i{}; i < 1'000; ++i) {
		cout << format("{:10}", uid(dre));
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 10:51:12
======================================================

#include <iostream>
#include <random>
#include <format>
#include <numeric>
#include "save.h"
using namespace std;

default_random_engine dre;
//---------
int main()
//---------
{
	// 랜덤 int 1000개를 생성해서 화면에 출력하라
	uniform_int_distribution<int> uid{ 0, 999'999'999 };

	int maxValue = numeric_limits<int>::min();

	for (int i{}; i < 1000; ++i) {
		int n = uid(dre);
		cout << format("{:10}", uid(dre));
		if (maxValue < n) {
			maxValue = n;
		}
	}
	cout << "\n가장 큰 수는: " << maxValue;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 10:53:33
======================================================

#include <iostream>
#include <random>
#include <format>
#include <numeric>
#include <fstream>
#include "save.h"
using namespace std;

default_random_engine dre;
//---------
int main()
//---------
{
	// 랜덤 int 1000개를 파일에 저장한다.
	uniform_int_distribution<int> uid{ 0, 10'000 };

	ofstream out{ "int 천개" };

	for (int i = 0; i < 1000; ++i) {
		out << uid(dre) << " ";
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 10:55:25
======================================================

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일 "int 천개"에는 int값 1000개가 저장되어 있다.]
// int는 값이 text로 저장되었으며 값과 값사이에는 공백이 있다.
// 파일을 읽어 int값을 화면에 출력하라


//---------
int main()
//---------
{
	ifstream in{ "int 천개" };
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	int n;
	for (int i = 0; i < 1000; ++i) {
		in >> n;
		cout << n << " ";
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 11:18:04
======================================================

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일 "int 천개"에는 int값 1000개가 저장되어 있다.
// int는 값이 text로 저장되었으며 값과 값사이에는 공백이 있다.
// 파일을 읽어 int값을 화면에 출력하라


//---------
int main()
//---------
{
	ifstream in{ "int 천개" };
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	int n{};
	int cnt{};
	while (in >> n) {
		cout << n << " ";
		++cnt;
	}
	cout << "\n모두 " << cnt << "개의 int를 읽었다.\n";
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 11:20:28
======================================================

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일 "int 천개"에는 int값 1000개가 저장되어 있다.
// int는 값이 text로 저장되었으며 값과 값사이에는 공백이 있다.
// 파일을 읽어 int값 1000개를 메모리에 저장하라.


//---------
int main()
//---------
{
	ifstream in{ "int 천개" };
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	int nArray[1000];
	int i{};
	while (in >> nArray[i++]);
	
	save("소스.cpp");
}



======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 11:24:25
======================================================

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일 "int 천개"에는 int값 1000개가 저장되어 있다.
// int는 값이 text로 저장되었으며 값과 값사이에는 공백이 있다.
// 파일을 읽어 int값 1000개를 메모리에 저장하라.


//---------
int main()
//---------
{
	ifstream in{ "int 천개" };
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	int nArray[1000];
	int i{};

	for (int i = 0; i < 1000; i++) {
		in >> nArray[i];
	}

	int maxValue = nArray[0];

	for (int n : nArray) {
		if (maxValue < n) {
			maxValue = n;
		}
	}
	cout << "최댓값은: " << maxValue;
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 11:25:25
======================================================

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

// [문제] 파일 "int 천개"에는 int값 1000개가 저장되어 있다.
// int는 값이 text로 저장되었으며 값과 값사이에는 공백이 있다.
// 파일을 읽어 int값 1000개를 메모리에 저장하라.


//---------
int main()
//---------
{
	ifstream in{ "int 천개" };
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	int nArray[1000];
	int i{};

	for (int i = 0; i < 1000; i++) {
		in >> nArray[i];
	}

	auto p = max_element(begin(nArray), end(nArray));

	cout << "\n최댓값은: " << *p;
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 11:26:23
======================================================

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

//---------
int main()
//---------
{
	array<int, 1000> a;
	cout << sizeof a << endl;
	save("소스.cpp");
}




======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 11:31:33
======================================================

#include <iostream>
#include <array>
#include "save.h"
using namespace std;

array<int, 10> ga;
int gx{ 123 };


//---------
int main()
//---------
{
	array<int, 10> a;
	int x{ 123 };

	cout << "스택에 있는 x:     " << addressof(x) << endl;
	cout << "스택에 있는 a[0]:  " << addressof(a[0]) << endl;
	cout << "DATA에 있는 gx:    " << addressof(gx) << endl;
	cout << "DATA에 있는 ga[0]: " << addressof(ga[0]) << endl;
	cout << "code에 있는 main:  " << addressof(main) << endl;
	cout << "code에 있는 save:  " << addressof(save) << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-15 수요일 오후 11:33:29
======================================================

#include <iostream>
#include <array>
#include "save.h"
using namespace std;



//--------
int main()
//--------
{
	array<int, 1000> a;
	for (int i = 0; i < 1000; ++i) {
		a[i] = i + 1;
	}

	// a에 있는 int 1000개를 file에 저장하려고 한다.
	// [문제] file의 크기는 얼마나 될까?


	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-22 수요일 오후 11:28:03
======================================================

#include <iostream>
#include <array>
#include "save.h"
using namespace std;



//--------
int main()
//--------
{
	cout << "int의 최솟값: " << numeric_limits<int>::min() << endl;
	cout << "int의 최댓값: " << numeric_limits<int>::max() << endl;

	save("소스.cpp");
}



======================================================
소스.cpp, 저장시간: 2023-03-22 수요일 오후 11:32:50
======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include "save.h"
using namespace std;

// [문제] int 1000개를 파일 "int 천개 메모리"에 메모리 그대로 저장하라.

//--------
int main()
//--------
{
	array<int, 1000> a;
	iota(a.begin(), a.end(), 1);

	ofstream out{ "int 천개 메모리", ios::binary };
	out.write((char*)&a, a.size() * sizeof(int));

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-22 수요일 오후 11:35:43
======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include "save.h"
using namespace std;

// [문제] 파일 "int 천개 메모리"에 있는 int값 1000개를 메모리에 저장한 후 화면에 출력하라.

//--------
int main()
//--------
{
	ifstream in{ "int 천개 메모리", ios::binary };
	if (!in) {
		cout << "파일에 문제가 있다" << endl;
		return 0;
	}
	array<int, 1000> a;
	in.read((char*)&a, sizeof(int) * a.size());

	for (int num : a) {
		cout << format("{:8}", num);
	}

	save("소스.cpp");
}



======================================================
소스.cpp, 저장시간: 2023-03-22 수요일 오후 11:43:40
======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include <random>
#include "save.h"
using namespace std;

// Dog 1000 객체를 파일 "Dog 천마리"를 binary mode로 열고
// 메모리 그대로 파일에 기록하라.

default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a', 'z' };
uniform_int_distribution<int> uidNum{ 1, 10000 };

class Dog {
	char c;
	int n;

public:
	Dog() {
		c = uidChar(dre);
		n = uidNum(dre);
	}

	friend ostream& operator << (ostream& os, const Dog& dog) {
		return os << "글자: " << dog.c << "숫자: " << dog.n;
	}
};

//--------
int main()
//--------
{
	array<Dog, 1000> dogs;

	ofstream out("Dog 천마리", ios::binary);
	out.write((char*)&dogs, dogs.size() * sizeof(int));

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-22 수요일 오후 11:51:50
======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include <random>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "Dog 생성" << endl; }
	~Dog() { cout << "Dog 소멸" << endl; }
};

void f()
{
	Dog* p = new Dog;
	throw 1;

	delete p;
}

//--------
int main()
//--------
{
	try {
		f();
	}
	catch (int n) {
		cout << "예외를 처리함" << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-22 수요일 오후 11:53:23
======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include <random>
#include "save.h"
using namespace std;

class Dog {
public:
	Dog() { cout << "Dog 생성" << endl; }
	~Dog() { cout << "Dog 소멸" << endl; }
};

void f()
{
	unique_ptr<Dog> p{ new Dog };

	// 문제가 생겼다
	throw 1;
	// 예외가 발생하면 unwinding을 하기 때문에 p가 소유한 Dog의 소멸자를 반드시 호출한다.
	cout << "이 문장이 출력되면 노트북 버려라" << endl;
}

//--------
int main()
//--------
{
	try {
		f();
	}
	catch (int n) {
		cout << "예외를 처리함" << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-22 수요일 오후 11:55:58
======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include <random>
#include "save.h"
using namespace std;

// [문제] "소스.cpp" 파일을 읽어 소문자를 대문자로 변환하여
// "소스대문자.cpp" 파일에 저장하라.

//--------
int main()
//--------
{
	ifstream in{ "소스.cpp" };
	ofstream out{ "소스대문자.cpp" };

	char c;

	while (in >> c) {
		c = toupper(c);
		out << c;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-22 수요일 오후 11:56:41
======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include <random>
#include "save.h"
using namespace std;

// [문제] "소스.cpp" 파일을 읽어 소문자를 대문자로 변환하여
// "소스대문자.cpp" 파일에 저장하라.

//--------
int main()
//--------
{
	ifstream in{ "소스.cpp" };
	ofstream out{ "소스대문자.cpp" };

	char c;

	in >> noskipws;
	while (in >> c) {
		c = toupper(c);
		out << c;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-22 수요일 오후 11:58:04
======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include <random>
#include "save.h"
using namespace std;

// [문제] "소스.cpp" 파일을 읽어 소문자를 대문자로 변환하여
// "소스대문자.cpp" 파일에 저장하라.

//--------
int main()
//--------
{
	ifstream in{ "소스.cpp" };
	ofstream out{ "소스대문자.cpp" };

	transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator<char>{out}, [](char c) {return c = toupper(c); });

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오전 12:00:12
======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include <random>
#include "save.h"
using namespace std;

// [문제] "소스.cpp" 파일을 읽어 소문자를 대문자로 변환하여
// "소스대문자.cpp" 파일에 저장하라.

//--------
int main()
//--------
{
	ifstream in{ "소스.cpp" };
	ofstream out{ "소스대문자.cpp" };

	transform(istreambuf_iterator<char>{in}, {}, ostreambuf_iterator<char>{out}, [](char c) {
		if (isdigit(c)) {
			c = '*';
		}
		return c;
		});

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 1:42:01
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 100만개를 만들고 random으로 채워라.
// 오름차순으로 정렬하라.
// 값을 채워라.

default_random_engine dre;
array<int, 1'000'000> numbers{};

class Dog {
public:
	bool operator()(int a, int b) {
		return a < b;
	}
};

//--------
int main()
//--------
{
	for (int n : numbers) {
		numbers[n] << n;
		++n;
	}
	sort(numbers.begin(), numbers.end(), Dog());


	save("소스.cpp");
}

// array의 end 위치는 마지막 원소에서 한칸 지난 위치

======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 1:42:36
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 100만개를 만들고 random으로 채워라.
// 오름차순으로 정렬하라.
// 값을 채워라.

default_random_engine dre;
array<int, 1'000'000> numbers{};

class Dog {
public:
	bool operator()(int a, int b) {
		return a < b;
	}
};

//--------
int main()
//--------
{
	Dog dog;
	cout << boolalpha << dog.operator()(3, 4) << endl;


	save("소스.cpp");
}

// array의 end 위치는 마지막 원소에서 한칸 지난 위치

======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 1:42:48
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 100만개를 만들고 random으로 채워라.
// 오름차순으로 정렬하라.
// 값을 채워라.

default_random_engine dre;
array<int, 1'000'000> numbers{};

class Dog {
public:
	bool operator()(int a, int b) {
		return a < b;
	}
};

//--------
int main()
//--------
{
	Dog dog;
	cout << boolalpha << dog.operator()(4, 3) << endl;


	save("소스.cpp");
}

// array의 end 위치는 마지막 원소에서 한칸 지난 위치

======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 1:43:24
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include <random>
#include "save.h"
using namespace std;

// [문제] int 100만개를 만들고 random으로 채워라.
// 오름차순으로 정렬하라.
// 값을 채워라.

default_random_engine dre;
array<int, 1'000'000> numbers{};

class Dog {
public:
	bool operator()(int a, int b) {
		return a < b;
	}
};

//--------
int main()
//--------
{
	Dog dog;
	cout << boolalpha << dog(200, 100) << endl;


	save("소스.cpp");
}

// array의 end 위치는 마지막 원소에서 한칸 지난 위치

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <fstream>
#include <array>
#include <numeric>
#include <format>
#include <random>
#include <ranges>
#include "save.h"
using namespace std;

// [문제] int 100만개를 만들고 random으로 채워라.
// 오름차순으로 정렬하라.
// 값을 채워라.

default_random_engine dre;
uniform_int_distribution uid{ 1, 1'000'000 };
array<int, 1'000'000> numbers{};

class Dog {
public:
	bool operator()(int a, int b) {
		return a < b;
	}
};

bool 함수(int a, int b) {
	return a > b;
}
//--------
int main()
//--------
{	
	for (int& number, numbers) {
		number = uid(dre);
	}

	// 정렬 방법은 sort에게 알려줘야 함 (함수를 인자로 전달)
	// sort는 기능만이 필요하다. (이름은 필요없다) 그래서 람다 이용
	// sort(numbers.begin(), numbers.end(), Dog());		// Dog를 이름 없는 객체로 만들어서 전달 (굳이 이름 있는 함수 넣을 이유가 있나?)
	// sort(numbers.begin(), numbers.end(), 함수);
	sort(numbers.begin(), numbers.end(), [](int a, int b) {
		return a < b;
		});

	for (int number : numbers |
		views::drop(numbers.size() - 100)) {
		cout << format("{:8}", number);
	}
	save("소스.cpp");
}

// array의 end 위치는 마지막 원소에서 한칸 지난 위치

======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 1:54:39
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include "save.h"
using namespace std;


//--------
int main()
//--------
{	
	int n;
	cout << typeid(n).name();


	[]() {
		cout << "안녕하세요? 난 람다입니다." << endl;
	};
	
	save("소스.cpp");
}




======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 1:56:12
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include "save.h"
using namespace std;


//--------
int main()
//--------
{	


	auto lambda = []() {
		cout << "안녕하세요? 난 람다입니다." << endl;
	};
	lambda();

	save("소스.cpp");
}




======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 1:56:46
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include "save.h"
using namespace std;


//--------
int main()
//--------
{	


	auto lambda = []() {
		cout << "안녕하세요? 난 람다입니다." << endl;
	};
	lambda();

	cout << typeid(lambda).name() << endl;

	save("소스.cpp");
}




======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 1:58:12
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include "save.h"
using namespace std;


//--------
int main()
//--------
{	
	class Dog {};
	Dog dog;
	cout << typeid(dog).name() << endl;

	auto lambda = []() {
		cout << "안녕하세요? 난 람다입니다." << endl;
	};
	lambda();

	cout << typeid(lambda).name() << endl;

	save("소스.cpp");
}




======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 1:59:06
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include "save.h"
using namespace std;

class Dog {};
//--------
int main()
//--------
{	

	Dog dog;
	cout << typeid(dog).name() << endl;

	auto lambda = []() {
		cout << "안녕하세요? 난 람다입니다." << endl;
	};
	lambda();

	cout << typeid(lambda).name() << endl;

	save("소스.cpp");
}




======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 1:59:23
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include "save.h"
using namespace std;

class Dog {};

auto lambda = []() {
	cout << "안녕하세요? 난 람다입니다." << endl;
};

//--------
int main()
//--------
{	

	Dog dog;
	cout << typeid(dog).name() << endl;


	lambda();

	cout << typeid(lambda).name() << endl;

	save("소스.cpp");
}




======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 2:07:52
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <array>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

class Dog {};

class lambda {
public:
	void operator()() {
		cout << "안녕하세요? 난 람다입니다." << endl;
	};
};
// 람다의 정체는 함수 객체다

//--------
int main()
//--------
{
	array<string, 5> a{
		"전광훈"s, "교회"s, "이번엔"s, "장위8구역"s, "사우나건물"s
	};

	sort(a.begin(), a.end(), [](const string& a, const string& b) {
		return a < b;
		});

	for (const string& str : a) {					// const reference 왜?
		cout << str << endl;
	}

	save("소스.cpp");
}

// 영어단어 맹글링



======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 2:08:05
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <array>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

class Dog {};

class lambda {
public:
	void operator()() {
		cout << "안녕하세요? 난 람다입니다." << endl;
	};
};
// 람다의 정체는 함수 객체다

//--------
int main()
//--------
{
	array<string, 5> a{
		"전광훈"s, "교회"s, "이번엔"s, "장위8구역"s, "사우나건물"s
	};

	sort(a.begin(), a.end(), [](const string& a, const string& b) {
		return a > b;
		});

	for (const string& str : a) {					// const reference 왜?
		cout << str << endl;
	}

	save("소스.cpp");
}

// 영어단어 맹글링



======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 2:08:27
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <array>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;

class Dog {};

class lambda {
public:
	void operator()() {
		cout << "안녕하세요? 난 람다입니다." << endl;
	};
};
// 람다의 정체는 함수 객체다

//--------
int main()
//--------
{
	array<string, 5> a{
		"전광훈"s, "교회"s, "이번엔"s, "장위8구역"s, "사우나건물"s
	};

	sort(a.begin(), a.end(), [](const string& a, const string& b) {		// 람다는 코드영역으로 들어간다.
		return a.size() < b.size();
		});

	for (const string& str : a) {					// const reference 왜?
		cout << str << endl;
	}

	save("소스.cpp");
}

// 영어단어 맹글링



======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 2:13:37
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <array>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;


//--------
int main()
//--------
{
	// 호출 가능한 타입
	// 1. 함수 포인터
	//

	cout << typeid(main).name() << endl;		// 함수 포인터
	save("소스.cpp");
}

// 영어단어 맹글링
// 타입이 같다는 의미: a = b; 해서 빨간줄 XX


======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 2:31:25
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <array>
#include <string>
#include <algorithm>
#include "save.h"
using namespace std;


//--------
int main()
//--------
{
	// 호출 가능한 타입
	// 1. 함수 포인터
	// 2. 함수 객체(함수 호출 연산자를 오버로딩한 클래스의 자체)
	// 3. 람다 (기능만이 필요한 경우에 사용, 이름 없는 함수)
	// 4. 멤버 함수 포인터
	// 5. function
	//

	cout << typeid(main).name() << endl;		// 함수 포인터
	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 2:54:18
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <random>
#include <algorithm>
#include <format>
#include <array>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution uidNum{ 1, 1'000'000 };
uniform_int_distribution uidLen{ 1, 50 };
uniform_int_distribution<int> uidName{ 'a', 'z' };

class Dog {
	int num;
	string name;

public:
	Dog() {
		num = uidNum(dre);
		int len = uidLen(dre);

		for (int i{}; i < len; ++i) {
			name += uidName(dre);
		}
	}
	
	void show() const {
		cout << format("{:7}, {}", num, name) << endl;
	}
};

//--------
int main()
//--------
{
	array<Dog, 10> dogs;
	for (const Dog& dog : dogs) {
		dog.show();
	}

	save("소스.cpp");
}

// hard wired coding (납땜 코딩했다)
// 스택의 지역변수로 akey 만듦, jump 찍고 있는 pointer (8byte)
// 함수의 이름은 번지이다.

======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 3:11:44
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <random>
#include <algorithm>
#include <format>
#include <array>
#include <ranges>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution uidNum{ 1, 1'000'000 };
uniform_int_distribution uidLen{ 1, 50 };
uniform_int_distribution<int> uidName{ 'a', 'z' };

class Dog {
	int num;
	string name;

public:
	Dog() {
		num = uidNum(dre);
		int len = uidLen(dre);

		for (int i{}; i < len; ++i) {
			name += uidName(dre);
		}
	}
	
	int getNum() const {
		return num;
	}

	string getName() {
		return name;
	}

	void show() const {
		cout << format("{:7}, {}", num, name) << endl;
	}
};

array<Dog, 1'000'000> dogs;

//--------
int main()
//--------
{
	// [문제] dogs를 Dog의 num기준 오름차순으로 정렬하라.
	// 뒤에서부터 100객체를 show()로 출력하라.
	
	sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getNum() < b.getNum();
		});

	for (const Dog& dog : dogs |
		views::drop(dogs.size() - 100)) {
		dog.show();
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 3:13:33
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <random>
#include <algorithm>
#include <format>
#include <array>
#include <ranges>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution uidNum{ 1, 1'00 };
uniform_int_distribution uidLen{ 1, 50 };
uniform_int_distribution<int> uidName{ 'a', 'z' };

class Dog {
	int num;
	string name;

public:
	Dog() {
		num = uidNum(dre);
		int len = uidLen(dre);

		for (int i{}; i < len; ++i) {
			name += uidName(dre);
		}
	}
	
	int getNum() const {
		return num;
	}

	string getName() const {
		return name;
	}

	void show() const {
		cout << format("{:7}, {}", num, name) << endl;
	}
};

array<Dog, 1'000'000> dogs;

//--------
int main()
//--------
{
	// [문제] dogs를 Dog의 num기준 오름차순으로 정렬하라.
	// 뒤에서부터 100객체를 show()로 출력하라.
	
	sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getName().size() < b.getName().size();
		});

	for (const Dog& dog : dogs |
		views::drop(dogs.size() - 100)) {
		dog.show();
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 3:13:47
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <random>
#include <algorithm>
#include <format>
#include <array>
#include <ranges>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution uidNum{ 1, 1'0000 };
uniform_int_distribution uidLen{ 1, 50 };
uniform_int_distribution<int> uidName{ 'a', 'z' };

class Dog {
	int num;
	string name;

public:
	Dog() {
		num = uidNum(dre);
		int len = uidLen(dre);

		for (int i{}; i < len; ++i) {
			name += uidName(dre);
		}
	}
	
	int getNum() const {
		return num;
	}

	string getName() const {
		return name;
	}

	void show() const {
		cout << format("{:7}, {}", num, name) << endl;
	}
};

array<Dog, 1'000'000> dogs;

//--------
int main()
//--------
{
	// [문제] dogs를 Dog의 num기준 오름차순으로 정렬하라.
	// 뒤에서부터 100객체를 show()로 출력하라.
	
	sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.getName().size() < b.getName().size();
		});

	for (const Dog& dog : dogs |
		views::drop(dogs.size() - 100)) {
		dog.show();
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-03-23 목요일 오후 3:18:05
======================================================

//======================================================
// 2023. STL. 3월 23 목56			월56목56 (4주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//------------------------------------------------------
// 정렬(sort) - callable type
//======================================================

#include <iostream>
#include <functional>
#include "save.h"
using namespace std;


//--------
int main()
//--------
{
	int (*fp)() = main;

	function<int()> f = main;
	f = fp;
	save("소스.cpp");
}

// Callable Types
// 1. Function pointer
// 2. funtion object 
// 3. lambda
// 위 3가지를 fuction으로 통합(generalization)
// 
// sort ( , , callbale)
//

======================================================
소스.cpp, 저장시간: 2023-04-02 일요일 오후 5:35:41
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 1일)
// 3.30 목(5주 1) - 학과 MT (e-class에 업로드, 출석은 대체)
// 4.3 예비군 훈련 - 수업 함
//-----------------------------------------------------------------------
// 관찰 클래스 작성 - String (자원을 확보하는 클래스) 
// 1.C++ 복습 
// 2. 앞으로 발전시켜서 STL 컨테이너로 만듦
//=======================================================================

#include <iostream>
#include <string>
#include <memory>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	save("소스.cpp");
	save("String.h");
	save("String.cpp");
}

======================================================
String.h, 저장시간: 2023-04-02 일요일 오후 5:35:41
======================================================

//-----------------------------------------------------------------------------
// String.h - 표준 String과 유사한 class
// 
// 2023. 3. 30
//-----------------------------------------------------------------------------
#pragma once
class string;
class ostream;

class String {
	size_t len{};			// 확보한 자원 수
	char* p{};				// 확보한 자원의 주소
	size_t id = ++sid;		// 객체 id

	static size_t sid;		// 멤버 변수에 static 변수?

public:
	// 생성자와 소멸자
	String();
	String(const char* str);
	~String();

	// 복사 생성자, 복사 할당 연산자
	String(const String& other);
	String& operator =(const String& other);

	// 이동생성자, 이동할당연산자
	String(String&& other);
	String& operator = (String&& other);

	// 연산자 overloading 함수들
	String operator +(const String& rhs) const;
	friend std::ostream& operator<<(std::ostream& os, const String& s);

public:
	// 그 외 멤버함수
	size_t size() const;
	void print(std::string) const;
	std::string getString() const;
};

======================================================
String.cpp, 저장시간: 2023-04-02 일요일 오후 5:35:41
======================================================

//-----------------------------------------------------------------------------
// String.cpp - 표준 String과 유사한 class
// 
// 2023. 3. 30
//-----------------------------------------------------------------------------
#include <string>
#include <iostream>
#include "String.h"
using namespace std;

bool 관찰{ false };			// 스페셜 함수의 동작을 관찰하려면 true로 바꿀 것
class String;

// 생성자와 소멸자
String::String()
{
	print("default 생성자");
}

String::String(const char* str)
	: len{ strlen(str) }
{
	p = new char[len];
	memcpy(p, str, len);		// DMA
	print("생성자(char*)");
}

String::~String()
{
	print("소멸자");
	delete[] p;
}

// 복사 생성자, 복사 할당 연산자
String::String(const String& other) {
	len = other.len;
	p = new char[len];
	memcpy(p, other.p, len);
	print("복사 생성자");
}

String& String::operator =(const String& other) {
	String temp;
	if (this == &other) {
		return *this;
	}
	delete[] p;

	len = other.len;
	p = new char[len];
	memcpy(p, other.p, len);

	print("복사 할당 연산자");
	return *this;
}

// 이동생성자, 이동할당연산자
String::String(String&& other)
{
	len = other.len;
	p = other.p;

	other.len = 0;
	other.p = nullptr;

	print("이동생성자"); 
}

String& String::operator= (String&& other)
{
	if (this == &other) {
		return *this;
	}
	delete[] p;

	len = other.len;
	p = other.p;

	other.len = 0;
	other.p = nullptr;

	print("이동 할당 연산자");
	return *this;
}


// 연산자 overloading 함수들
String String::operator +(const String& rhs) const {
	String temp;

	temp.len = len + rhs.len;
	temp.p = new char[temp.len];
	memcpy(temp.p, p, len);
	memcpy(temp.p + len, rhs.p, rhs.len);

	return temp;
}

std::ostream& operator<<(std::ostream& os, const String& s)
{
	for (int i{}; i < s.len; ++i) {
		os << s.p[i];
	}
	return os;
}

// 그 외 멤버함수
size_t String::size() const
{
	return len;
}

void String::print(std::string s) const {
	if (관찰) {
		std::cout << "[" << id << "]: " << s << ", 개수: "
			<< len << ", 번지: " << (void*)p << std::endl;
	}
}

std::string String::getString() const {
	return std::string(p, len);
}
size_t String::sid{ 0 };			// 이 변수는 class 밖에서 초기화한다.



======================================================
소스.cpp, 저장시간: 2023-04-02 일요일 오후 6:23:22
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 1일)
// 4.3 예비군 훈련 - 수업 함
//-----------------------------------------------------------------------
// STL 시작
//=======================================================================

#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	save("소스.cpp");
}

/*
 STL에서 중요한 것들: *Constainers library, *Algorithms library, Iterators library
 *Concepts library, *Ranges library, unique_ptr, String library
 
 Sequence Containers					array, vector, deque, forward_list, list
 Associative Containers					set, multiset, map, multimap
 Unordered Associative Containers		hash table
*/

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 1:57:27
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	array<String, 3> a;

	save("소스.cpp");
}

/*
 STL에서 중요한 것들: *Constainers library, *Algorithms library, Iterators library
 *Concepts library, *Ranges library, unique_ptr, String library
 
 Sequence Containers					array, vector, deque, forward_list, list
 Associative Containers					set, multiset, map, multimap
 Unordered Associative Containers		unordered_set, unordered_map (hash table)

 -

 Containers are objects that store other objects.
 array<String, 3> a;
 'String' object 를 담을 수 있는 array object 'a'

 
*/

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 1:59:17
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	cout << a.front();

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 2:00:25
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	a.front() = 123;
	cout << a.front();

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 2:10:30
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	// STL의 컨테이너의 원소에 access
	// 모든 값을 출력하기
	array<int, 10>::iterator p = a.begin();
	cout << *p << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 2:11:09
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	// STL의 컨테이너의 원소에 access
	// 모든 값을 출력하기
	array<int, 10>::iterator p = a.begin();
	while (p != a.end()) {
	cout << *p << endl;
	++p;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 2:15:26
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	// STL의 컨테이너의 원소에 access
	// 모든 값을 출력하기
	for (auto i = a.begin(); i != a.end(); ++i) {
		cout << *i << endl;
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 2:19:06
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	// STL의 컨테이너의 원소에 access
	// 모든 값을 출력하기
	for (int i = 0; i < a.size(); ++i) {
		cout << a[i] << endl;
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 2:19:55
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	// STL의 컨테이너의 원소에 access
	// 모든 값을 출력하기
	for (int n : a) {
		cout << n << endl;
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 2:33:22
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	// STL의 컨테이너의 원소에 access
	// 모든 값을 출력하기
	for (int n : a) {
		cout << (n*=10) << endl;
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 2:33:35
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	// STL의 컨테이너의 원소에 access
	// 모든 값을 출력하기
	for (int& n : a) {
		cout << (n*=10) << endl;
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 2:38:56
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	// STL의 컨테이너의 원소에 access
	// 모든 값을 뒤에서부터 출력하기

	for (auto p = a.begin(); p != a.end(); ++p) {
		cout << *p << ' ';
	}
	cout << endl;
	save("소스.cpp");
}

/*
p = a.rbegin()
*p 하면 원래 enditer줘야하나 마지막 원소 준다
= iterator adopter
*/


======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 2:39:09
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	array<int, 10> a{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	// STL의 컨테이너의 원소에 access
	// 모든 값을 뒤에서부터 출력하기

	for (auto p = a.rbegin(); p != a.rend(); ++p) {
		cout << *p << ' ';
	}
	cout << endl;
	save("소스.cpp");
}

/*
p = a.rbegin()
*p 하면 원래 enditer줘야하나 마지막 원소 준다
= iterator adopter
*/


======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 3:00:10
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	관찰 = true;

	// [문제] 파일 "소스.cpp"에 있는 단어 30개를 a로 읽어라.
	array<String, 30> a;

	ifstream in{ "소스.cpp" };
	if (!in) {
		cout << "\"소스.cpp\"를 열 수 없습니다." << endl;
		return 0;
	}

	for (int i = 0; i < 30; ++i) {
		in >> a[i];
	}

	// a의 내용을 모두 출력
	for (String& s : a) {
		cout << s << endl;
	}
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 3:03:10
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	관찰 = true;

	array<std::string, 30> a;

	ifstream in{ "소스.cpp" };
	if (!in) {
		cout << "\"소스.cpp\"를 열 수 없습니다." << endl;
		return 0;
	}

	for (int i = 0; i < 30; ++i) {
		in >> a[i];
	}

	for (std::string& s : a) {
		cout << s << endl;
	}
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 3:05:07
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	관찰 = true;

	array<std::string, 30> a;

	ifstream in{ "소스.cpp" };
	if (!in) {
		cout << "\"소스.cpp\"를 열 수 없습니다." << endl;
		return 0;
	}

	for (int i = 0; i < 30; ++i) {
		in >> a[i];
	}

	// a의 길이 기준 오름차순으로 a를 정렬하라.
	
	sort(a.begin(), a.end(), [](const std::string& a, auto& b) {
		return a.size() < b.size();
		});

	// 출력
	for (std::string& s : a) {
		cout << s << endl;
	}
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 3:06:10
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	관찰 = true;

	array<String, 30> a;

	ifstream in{ "소스.cpp" };
	if (!in) {
		cout << "\"소스.cpp\"를 열 수 없습니다." << endl;
		return 0;
	}

	for (int i = 0; i < 30; ++i) {
		in >> a[i];
	}

	// a의 길이 기준 오름차순으로 a를 정렬하라.
	
	sort(a.begin(), a.end(), [](const String& a, auto& b) {
		return a.size() < b.size();
		});

	// 출력
	for (const String& s : a) {
		cout << s << endl;
	}
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 3:07:43
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{

	array<String, 30> a;

	ifstream in{ "소스.cpp" };
	if (!in) {
		cout << "\"소스.cpp\"를 열 수 없습니다." << endl;
		return 0;
	}

	for (int i = 0; i < 30; ++i) {
		in >> a[i];
	}

	// a의 길이 기준 오름차순으로 a를 정렬하라.
	관찰 = true;
	sort(a.begin(), a.end(), [](const String& a, auto& b) {
		return a.size() < b.size();
		});
	관찰 = false;

	// 출력
	for (const String& s : a) {
		cout << s << endl;
	}
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 3:12:52
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	관찰 = true;

	// [문제] 키보드에서 입력한 int를 10개만  array를 이용하여 저장하라.
	// 합계를 화면에 출력하라.

	array<int, 10> a;
	int num{};
	
	for (int i{}; i < a.size(); ++i) {
		cin >> a[i];
		num += a[i];
	}
	
	cout << num;
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-03 월요일 오후 3:20:05
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	관찰 = true;

	// [문제] 키보드에서 입력한 int를 10개만  array를 이용하여 저장하라.
	// 합계를 화면에 출력하라.

	array<int, 10> a;
	
	for (int i{}; i < a.size(); ++i) {
		cin >> a[i];
	}
	cin.clear();

	int sum = *a.begin();
	cout << *a.begin();
	for (auto i = a.begin() + 1; i != a.end(); ++i) {
		cout << " + " << *i;
		sum += *i;
	}
	cout << " = " << sum;
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-06 목요일 오후 1:36:40
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	vector<int> v{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	cout << "vector<int>의 크기: " << sizeof(v);
	
	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-06 목요일 오후 1:48:55
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	vector<int> v{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	// v의 모든 값을 출력한다.
	// v에 20을 추가한다.
	// v의 모든 값을 출력한다.

	for (int n : v) {
		cout << n << endl;
	}

	v.push_back(20);
	cout << endl;

	for (int n : v) {
		cout << n << endl;
	}
	
	save("소스.cpp");
}

// v의 크기: 24byte (동적할당 했다는 뜻, 무슨 자료형을 담아도 v의 크기는 같다), v = v의 시작번지
// 스택의 v: 칸당 8byte, 3칸 (10=개수)(동적할당한 공간의 주소)(15=전체)
/*
class vector {
	size_t	size;
	int*	p;
	size_t	capacity;
}
*/


======================================================
소스.cpp, 저장시간: 2023-04-06 목요일 오후 1:53:20
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

extern bool 관찰;
//--------
int main()
//--------
{
	vector<int> v{1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

	// v의 모든 값을 출력한다.
	// v에 20을 추가한다.
	// v의 모든 값을 출력한다.

	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << ' ';
	}

	v.push_back(20);
	cout << endl;

	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << ' ';
	}
	
	save("소스.cpp");
}



======================================================
소스.cpp, 저장시간: 2023-04-06 목요일 오후 2:37:13
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <vector>
#include <thread>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] "소스.cpp의 단어를 모두 읽어 오름차순으로 정렬한 후 화면에 출력하시오."

//--------
int main()
//--------
{
	vector<String> v;

	ifstream in{ "소스.cpp" };
	if (!in) {
		return 0;
	}

	String s;
	while (in >> s) {
		v.push_back(s);
	}

	sort(v.begin(), v.end(), [](const String& a, const String& b) {
		return a.getString() < b.getString();
		});

	for (String b : v) {
		cout << b << endl;
	}
	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-06 목요일 오후 2:40:21
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <vector>
#include <thread>
#include <fstream>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] "소스.cpp의 단어를 모두 읽어 오름차순으로 정렬한 후 화면에 출력하시오."

//--------
int main()
//--------
{
	vector<String> v;
	v.reserve(200);

	ifstream in{ "소스.cpp" };
	if (!in) {
		return 0;
	}

	String s;
	while (in >> s) {
		v.push_back(s);
	}

	sort(v.begin(), v.end(), [](const String& a, const String& b) {
		return a.getString() < b.getString();
		});

	for (String b : v) {
		cout << b << endl;
	}
	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-06 목요일 오후 2:48:52
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <vector>
#include <thread>
#include <fstream>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] 키보드에서 int를 입력받아 합계를 출력와 평균을 출력하라.

//--------
int main()
//--------
{
	vector<int> v;
	v.reserve(20);
	int n;

	cout << "숫자를 입력하면 합계와 평균을 알려줍니다." << endl;
	while (cin >> n) {
		v.push_back(n);
	}

	// numeric 함수 중 accumulate
	int sum = accumulate(v.begin(), v.end(), 0);
	cout << "합계: " << sum << ", 평균: " << (double)sum / v.size();

	save("소스.cpp");
}

// ctrl z 누르면 입력 끝

======================================================
소스.cpp, 저장시간: 2023-04-06 목요일 오후 2:52:59
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <vector>
#include <thread>
#include <fstream>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] 키보드에서 단어를 입력받아 오름차순 정렬 후 출력하라.

//--------
int main()
//--------
{
	vector<std::string> v;
	v.reserve(20);
	std::string n;

	cout << "단어를 입력하면 정렬해서 출력합니다." << endl;
	while (cin >> n) {
		v.push_back(n);
	}

	sort(v.begin(), v.end());

	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << endl;
	}
	save("소스.cpp");
}

// ctrl z 누르면 입력 끝

======================================================
소스.cpp, 저장시간: 2023-04-06 목요일 오후 2:59:00
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <vector>
#include <thread>
#include <fstream>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] 키보드에서 단어를 입력받아 오름차순 정렬 후 출력하라.

//--------
int main()
//--------
{
	vector<String> v{ istream_iterator<String>{cin}, {} };

	sort(v.begin(), v.end(), [](auto& a, auto& b) {
		return a.getString() < b.getString();
		});

	for (auto& s : v) {
		cout << s << endl;
	}

	save("소스.cpp");
}

// ctrl z 누르면 입력 끝


======================================================
소스.cpp, 저장시간: 2023-04-06 목요일 오후 3:07:24
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <vector>
#include <fstream>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] "소스.cpp"의 글자(공백 제외)를 모두 읽어 오름차순 정렬 후 출력하라.

//--------
int main()
//--------
{
	ifstream in{ "소스.cpp" };
	vector<char> v{ istream_iterator<char>{in}, {} };

	sort(v.begin(), v.end());

	for (auto& s : v) {
		cout << s << endl;
	}
	
	save("소스.cpp");
}

// 효율적인 코드, 고수준

======================================================
소스.cpp, 저장시간: 2023-04-06 목요일 오후 3:14:18
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (5주 2일)
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <array>
#include <vector>
#include <fstream>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	관찰 = true;

	vector<String> v{"123", "abcde", "7890"};

	// 메모리 그림으로 그릴 수 있니?
	
	save("소스.cpp");
}

// 효율적인 코드, 고수준
// vector를 초기화하면 stack에 임시 객체를 생성한 후 free store로 복사하여 저장한다. 그 후 임시객체 소멸

======================================================
소스.cpp, 저장시간: 2023-04-10 월요일 오후 2:09:42
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (6주 2일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	관찰 = true;

	vector<String> v;
	v.push_back("4월24일");
	v.push_back("중간시험");

	
	save("소스.cpp");
}

/*
[1]: 생성자(char*), 개수: 7, 번지: 000002A6D43D3B10
[2]: 이동생성자, 개수: 7, 번지: 000002A6D43D3B10
[1]: 소멸자, 개수: 0, 번지: 0000000000000000					// 여기까지 "4월24일" 생성해서 v에 넣기
[3]: 생성자(char*), 개수: 8, 번지: 000002A6D43D3AE0			// 3번 임시객체 "중간시험" 생성
[4]: 이동생성자, 개수: 8, 번지: 000002A6D43D3AE0				// "중간시험"을 새로 생성한 v의 늘린부분에 넣기
[5]: 복사 생성자, 개수: 7, 번지: 000002A6D43D39C0				// 새로운 4번 객체 "4월24일" 새 v에 복사생성 ★ 왜 이동 안하고 복사했을까?: 안정성을 위해(원본의 훼손 방지)
[2]: 소멸자, 개수: 7, 번지: 000002A6D43D3B10					// 2번 객체 삭제
[3]: 소멸자, 개수: 0, 번지: 0000000000000000					// 3번 객체 삭제
[5]: 소멸자, 개수: 7, 번지: 000002A6D43D39C0
[4]: 소멸자, 개수: 8, 번지: 000002A6D43D3AE0
*/

======================================================
소스.cpp, 저장시간: 2023-04-10 월요일 오후 2:46:28
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (6주 2일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	관찰 = true;

	vector<String> v;
	v.reserve(3);

	v.push_back("4월24일");
	v.push_back("중간시험");

	
	save("소스.cpp");
}

/*
v.reserve(3)											// v의 capacity가 3이 된다. v의 공간을 미리 할당한다. 
v를 생성하고 예약하자! 무식하게 푸시백으로 때려박지 말자!

[1]: 생성자(char*), 개수: 7, 번지: 0000024B25637AE0		// 1번 임시 객체 "4월24일" 생성
[2]: 이동생성자, 개수: 7, 번지: 0000024B25637AE0			// 1번 객체 v로 이동
[1]: 소멸자, 개수: 0, 번지: 0000000000000000				// 1번 임시 객체 사망
[3]: 생성자(char*), 개수: 8, 번지: 0000024B25637BB0		// 2번 임시 객체 "중간시험" 생성
[4]: 이동생성자, 개수: 8, 번지: 0000024B25637BB0			// 2번 객체 v로 이동
[3]: 소멸자, 개수: 0, 번지: 0000000000000000				// 사망
[2]: 소멸자, 개수: 7, 번지: 0000024B25637AE0				// 2번 임시객체 사망
[4]: 소멸자, 개수: 8, 번지: 0000024B25637BB0				// 사망

어차피 스택에 생성하고 v로 이동하는데, 그냥 v에 생성하면 안될까?
*/



======================================================
소스.cpp, 저장시간: 2023-04-10 월요일 오후 2:57:08
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (6주 2일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	관찰 = true;

	vector<String> v;
	v.reserve(3);

	v.emplace_back("4월24일");
	v.emplace_back("중간시험");

	
	save("소스.cpp");
}

/*
[1]: 생성자(char*), 개수: 7, 번지: 000002517B447A40
[2]: 생성자(char*), 개수: 8, 번지: 000002517B447A60
[1]: 소멸자, 개수: 7, 번지: 000002517B447A40
[2]: 소멸자, 개수: 8, 번지: 000002517B447A60

emplace_back 중요!
원소는 생성자 함수를 이용해서 v에 생성된다 (placement-new)

평균적을 상수 시간에 일어나는 동작이다.
*/

======================================================
소스.cpp, 저장시간: 2023-04-10 월요일 오후 3:01:10
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (6주 2일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	관찰 = true;

	vector<String> v;
	v.reserve(3);

	v.emplace_back(String("4월24일"));
	v.emplace_back(String("중간시험"));

	
	save("소스.cpp");
}

/*
[1]: 생성자(char*), 개수: 7, 번지: 0000029D6D203B10
[2]: 이동생성자, 개수: 7, 번지: 0000029D6D203B10
[1]: 소멸자, 개수: 0, 번지: 0000000000000000
[3]: 생성자(char*), 개수: 8, 번지: 0000029D6D203A00
[4]: 이동생성자, 개수: 8, 번지: 0000029D6D203A00
[3]: 소멸자, 개수: 0, 번지: 0000000000000000
[2]: 소멸자, 개수: 7, 번지: 0000029D6D203B10
[4]: 소멸자, 개수: 8, 번지: 0000029D6D203A00

emplacing은 생성자에 전달될 인자만 주는 것!
이렇게 쓰면 효과 없다
*/

======================================================
소스.cpp, 저장시간: 2023-04-10 월요일 오후 3:03:50
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (6주 2일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	관찰 = true;

	vector<String> v;
	v.reserve(3);

	v.emplace_back();
	v.emplace_back();

	// v.emplace_back( String() ); 하면 바보
	
	save("소스.cpp");
}

// 기본 생성자


======================================================
소스.cpp, 저장시간: 2023-04-10 월요일 오후 3:11:35
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (6주 2일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<String> v{"1", "12", "123"};
	관찰 = true;

	// v를 길이 기준 내림차순으로 정렬하라.
	sort(v.begin(), v.end(), [](const String &a, const String &b) {
		return a.size() > b.size();
		});
	관찰 = false;

	// 출력하라.
	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << endl;
	}
	
	save("소스.cpp");
}

/*
sort는 왜 복사 안하고 이동할까? 프로그래머가 이동의 안전을 보장했기 때문!
[7]: 이동생성자, 개수: 2, 번지: 0000016F6EB73A90
[5]: 이동 할당 연산자, 개수: 1, 번지: 0000016F6EB73A70
[4]: 이동 할당 연산자, 개수: 2, 번지: 0000016F6EB73A90
[7]: 소멸자, 개수: 0, 번지: 0000000000000000
[8]: 이동생성자, 개수: 3, 번지: 0000016F6EB739D0
[6]: 이동 할당 연산자, 개수: 1, 번지: 0000016F6EB73A70
[5]: 이동 할당 연산자, 개수: 2, 번지: 0000016F6EB73A90
[4]: 이동 할당 연산자, 개수: 3, 번지: 0000016F6EB739D0
[8]: 소멸자, 개수: 0, 번지: 0000000000000000
123
12
1
*/

======================================================
소스.cpp, 저장시간: 2023-04-10 월요일 오후 3:19:45
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (6주 2일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<String> v{"1", "12", "123"};
	관찰 = true;

	v.push_back("123");
	v.push_back("abc");
	관찰 = false;

	// 출력하라.
	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << endl;
	}
	
	save("소스.cpp");
}

/*
noexcept: 예외 없음 키워드
*/

1. reserve()
2. emplace_back()


======================================================
소스.cpp, 저장시간: 2023-04-13 목요일 오후 1:42:46
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	관찰 = true;
	vector<String> v;
	v.reserve(3);

	v.push_back("123");
	v.push_back("abc");
	관찰 = false;

	// 출력하라.
	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << endl;
	}
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-13 목요일 오후 1:43:15
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	관찰 = true;
	vector<String> v;
	v.reserve(3);

	v.emplace_back("123");
	v.emplace_back("abc");
	관찰 = false;

	// 출력하라.
	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << endl;
	}
	
	save("소스.cpp");
}

// class vector 생성할때만 emplace, 기본 자료형은 push

======================================================
소스.cpp, 저장시간: 2023-04-13 목요일 오후 2:02:53
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include <fstream>
#include <string>
#include <filesystem>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] "소스.cpp"의 영문자만 (대문자는 소문자로 바꿔서) vector<char>에 저장하라
// 각 문자의 개수를 다음과 같이 출력하라
// a - 10
// b - 3
// ...
// z - 1

//--------
int main()
//--------
{
	vector<char> v;
	std::string fname{ "소스.cpp" };
	
	ifstream in{ fname };
	if (!in) {
		return 0;
	}

	auto fileSize = filesystem::file_size(fname);
	cout << fname << " 파일 크기: " << fileSize << endl;

	v.reserve(fileSize);
	cout << "벡터의 용량: " << v.capacity() << endl;

	char c;
	while(in >> c) {
		if (isalpha(c) == true) {
			c = tolower(c);
			v.push_back(c);
		}
	}

	for (int i : v) {
		cout << v[i];
	}
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-13 목요일 오후 2:11:09
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include <fstream>
#include <string>
#include <filesystem>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] "소스.cpp"의 영문자만 (대문자는 소문자로 바꿔서) vector<char>에 저장하라
// 각 문자의 개수를 다음과 같이 출력하라
// a - 10
// b - 3
// ...
// z - 1

//--------
int main()
//--------
{
	vector<char> v;
	std::string fname{ "소스.cpp" };
	
	ifstream in{ fname };
	if (!in) {
		return 0;
	}

	auto fileSize = filesystem::file_size(fname);
	cout << fname << " 파일 크기: " << fileSize << endl;

	v.reserve(fileSize);
	cout << "벡터의 용량: " << v.capacity() << endl;

	char c;
	while(in >> c) {
		if (isalpha(c)) {
			v.push_back(tolower(c));
		}
	}

	array<int, 26> alphanum{};

	for (char c : v) {
		++alphanum[c - 'a'];
	}

	for (int i = 0; i < alphanum.size(); ++i) {
		cout << static_cast<char>('a' + i) << " - " << alphanum[i] << endl;
	}
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-13 목요일 오후 2:13:41
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include <fstream>
#include <string>
#include <filesystem>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] "소스.cpp"의 영문자만 (대문자는 소문자로 바꿔서) 개수를 세라
// 각 문자의 개수를 다음과 같이 출력하라
// a - 10
// b - 3
// ...
// z - 1

//--------
int main()
//--------
{
	ifstream in{ "소스.cpp "};
	array<int, 26> alphanum{};

	char c;
	while(in >> c) {
		if (isalpha(c)) {
			++alphanum[tolower(c) - 'a'];
		}
	}

	for (int i = 0; i < alphanum.size(); ++i) {
		cout << static_cast<char>('a' + i) << " - " << alphanum[i] << endl;
	}
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-13 목요일 오후 2:33:01
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include <fstream>
#include <string>
#include <filesystem>
#include <array>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v{ 1, 2, 3, 4, 5 };

	// [문제] v에서 3을 지워라. -> { 1, 2, 4, 5 }
	// 알고리즘 remove를 사용하시오
	
	remove(v.begin(), v.end(), 3);
	v.erase(v.end() - 1);
	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << ' ';
	}
	
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-13 목요일 오후 2:43:15
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v{ 1, 2, 3, 4, 5 };

	// [문제] v에서 3을 지워라. -> { 1, 2, 4, 5 }
	// 알고리즘 remove를 사용하시오
	
	vector<int>::iterator p = remove(v.begin(), v.end(), 3);

	// 실제 size 조정은 vector만 할 수 있다
	v.erase(p, v.end());
	// p 위치부터 end까지 지움
	
	for (int i = 0; i < v.size(); ++i) {
		cout << v[i] << ' ';
	}
	
	cout << endl;

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-13 목요일 오후 2:52:07
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	vector<int>::iterator p;
	// [문제] v에서 짝수를 제거하라.
	// remove_if
	while (true) {
		p = remove_if(v.begin(), v.end(), [](int n) {
			return !(n % 2);
			});
		v.erase(p, v.end());
		if (v.size() == 50) {
			break;
		}
	}

	for (int n : v) {
		cout << n << ' ';
	}
	cout << endl;
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-13 목요일 오후 2:58:18
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	vector<int>::iterator p;
	// [문제] v에서 짝수를 제거하라.
	// remove_if
	// erase-remove idiom

	p = remove_if(v.begin(), v.end(), [](int n) {
		return !(n & 1);
		});
	v.erase(p, v.end());

	for (int n : v) {
		cout << n << ' ';
	}
	cout << endl;
	save("소스.cpp");
}

// _Pred : 조건 (predicate)

======================================================
소스.cpp, 저장시간: 2023-04-13 목요일 오후 3:02:25
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v(100);
	iota(v.begin(), v.end(), 1);

	// [문제] v에서 짝수를 제거하라.
	// remove_if
	// erase-remove idiom --> C++20부터는 전역함수 erase_if를 사용

	erase_if(v, [](int n) {
		return !(n & 1);
		});

	for (int n : v) {
		cout << n << ' ';
	}
	cout << endl;
	save("소스.cpp");
}

// _Pred : 조건 (predicate)

======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 1:45:04
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<String> v{ "1", "2", "345", "4", "5" };

	// [문제] v에서 "3"을 제거하라
	erase(v, "345");

	for (String& s : v) {
		cout << s << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

/*
이항 '==': 왼쪽 피연산자로 'String' 형식을 사용하는 연산자가 없거나 허용되는 변환이 없습니다.
-> erase의 "3"과 v의 "3"을 비교할 수 없다.

해결하려면 - 글자수와 안의 내용이 같은지 비교할 수 있도록 만들어야 한다
*/


======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 1:48:12
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<String> v{ "1", "2", "3", "4", "5", "3", "3"};

	// [문제] v에서 "3"을 제거하라
	erase(v, "3");

	for (String& s : v) {
		cout << s << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

//					  STL
// Container	--  iterator	--	  Algorithm
// 둘 사이를 연결해준다 iterator
// Container와 Algorithm을 분리하기 위함
// 분리하지 않으면 hard-wired coding, algorithm이 직접 접근하면 vector 전용이 되어버린다
// 

======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 2:02:53
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<String> v{ "1", "2", "4", "5"};
	// [문제] v의 2와 4 사이에 "3"을 삽입하라.
	// Insert
	vector<String>::iterator iter;
	v.insert(v.begin()+2, "3");

	for (String& s : v) {
		cout << s << ' ';
	}

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 2:03:07
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<String> v{ "1", "2", "4", "5"};
	// [문제] v의 2와 4 사이에 "3"을 삽입하라.
	// Insert
	vector<String>::iterator iter;
	v.insert(v.begin()+2, 100, "3");

	for (String& s : v) {
		cout << s << ' ';
	}

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 2:03:30
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<String> v{ "1", "2", "4", "5"};
	// [문제] v의 2와 4 사이에 "3"을 삽입하라.
	// Insert
	vector<String>::iterator iter;
	v.insert(v.begin()+2, v.begin(), v.end());

	for (String& s : v) {
		cout << s << ' ';
	}

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 2:05:03
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<String> v{ "1", "2", "4", "5"};
	// [문제] v의 2와 4 사이에 "3"을 삽입하라.
	// Insert
	관찰 = true;
	v.insert(v.begin() + 2, "3");
	관찰 = false;

	for (String& s : v) {
		cout << s << ' ';
	}

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 2:06:14
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// STL 시작 - 표준 문서 (컨테이너), cppreference에서 컨테이너 공부해 보기
//=======================================================================

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<String> v{ "1", "22", "4444", "55555"};
	// [문제] v의 2와 4 사이에 "3"을 삽입하라.
	// Insert
	관찰 = true;
	v.insert(v.begin() + 2, "333");
	관찰 = false;

	for (String& s : v) {
		cout << s << ' ';
	}

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 2:19:37
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// Sequence Container - Vector
// 1. 공간을 마련하고 사용 - reserve()
// 2. push_back보다 emplace_back()을 사용
// 3. 중간에서 원소를 자주 삽입/삭제한다면 다른 Container를 사용하라
//=======================================================================

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<String> v{ "1", "22", "4444", "55555"};
	// [문제] v의 2와 4 사이에 "3"을 삽입하라.
	// Insert
	관찰 = true;
	auto p = v.begin();
	++p;
	++p;
	v.emplace(p, "333");
	관찰 = false;

	for (String& s : v) {
		cout << s << ' ';
	}

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 2:37:19
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// Sequence Container - deque
//=======================================================================

#include <iostream>
#include <deque>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	deque<int> d{ 1, 2, 3, 4, 5 };
	// d의 앞에 0을, 뒤에 6을 추가하라.
	d.push_back(6);
	d.push_front(0);

	for (int n : d) {
		cout << n << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

// deque: push_back이나 push_front시 iterator를 무효화 시키지 않는다. (메모리 이사가지 않는다)

======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 2:39:19
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// Sequence Container - deque
//=======================================================================

#include <iostream>
#include <deque>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	deque<int> d{ 1, 2, 3, 4, 5 };
	// d의 앞에 0을, 뒤에 6을 추가하라.
	d.push_back(6);
	d.push_front(0);

	for (int i = 0; i < d.size(); ++i) {
		cout << d[i] << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 2:44:20
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// Sequence Container - deque
//=======================================================================

#include <iostream>
#include <deque>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v{ 0, 1, 2, 3, 4, 5, 6 };
	// [문제] v의 각 원소가 저장된 메모리 주소를 출력하라.
	for (int i = 0; i < v.size(); ++i) {
		cout << i << "이 저장된 주소: " << &v[i] << endl;
	}
	cout << endl;

	deque<int> d{ 1, 2, 3, 4, 5 };
	// d의 앞에 0을, 뒤에 6을 추가하라.
	d.push_back(6);
	d.push_front(0);

	for (int i = 0; i < d.size(); ++i) {
		cout << i << "이 저장된 주소: " << &d[i] << endl;
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 2:44:41
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// Sequence Container - deque
//=======================================================================

#include <iostream>
#include <deque>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v{ 0, 1, 2, 3, 4, 5, 6 };
	// [문제] v의 각 원소가 저장된 메모리 주소를 출력하라.
	for (int i = 0; i < v.size(); ++i) {
		cout << i << "이 저장된 주소: " << &v[i] << endl;
	}
	cout << endl;

	deque<int> d{ 0, 1, 2, 3, 4, 5, 6 };
	// d의 앞에 0을, 뒤에 6을 추가하라.

	for (int i = 0; i < d.size(); ++i) {
		cout << i << "이 저장된 주소: " << &d[i] << endl;
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 2:45:14
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// Sequence Container - deque
//=======================================================================

#include <iostream>
#include <deque>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v{ 0, 1, 2, 3, 4, 5, 6 };
	// [문제] v의 각 원소가 저장된 메모리 주소를 출력하라.
	for (int i = 0; i < v.size(); ++i) {
		cout << i << "이 저장된 주소: " << &v[i] << endl;
	}
	cout << endl;

	deque<int> d{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	// d의 앞에 0을, 뒤에 6을 추가하라.

	for (int i = 0; i < d.size(); ++i) {
		cout << i << "이 저장된 주소: " << &d[i] << endl;
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 2:46:37
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// Sequence Container - deque
//=======================================================================

#include <iostream>
#include <deque>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	deque<String> d{ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };
	// d의 앞에 0을, 뒤에 6을 추가하라.

	for (int i = 0; i < d.size(); ++i) {
		cout << i << "이 저장된 주소: " << &d[i] << endl;
	}
	cout << endl;

	save("소스.cpp");
}

// deque 자료구조는 연속되지 않음
// 
// vector ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ
// deque  ㅁㅁㅁㅁ-ㅁㅁㅁㅁ-ㅁㅁㅁㅁ
// list   ㅁ-ㅁ-ㅁ-ㅁ-ㅁ
// 
// vector - deque - list 순으로 캐싱 좋음


======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 3:02:04
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// Container - deque
//=======================================================================

#include <iostream>
#include <deque>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] 어느 컨테이너가 더 많은 int를 저장할 수 있나 (benchmark)
// x86 모드에서 실행

// vector<int> v			// 최대 원소 수 - 136216567


//--------
int main()
//--------
{
	vector<int> v;

	try {
		while (true) {
			v.push_back(1);
		}
	}
	catch(exception &e) {
		cout << "메모리 부족: " << e.what() << endl;
		cout << "v의 원소 수: " << v.size() << endl;
	}

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 3:02:34
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// Container - deque
//=======================================================================

#include <iostream>
#include <deque>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] 어느 컨테이너가 더 많은 int를 저장할 수 있나 (benchmark)
// x86 모드에서 실행

// vector<int> v			// 최대 원소 수 - 136216567
deque<int> v;

//--------
int main()
//--------
{
	try {
		while (true) {
			v.push_back(1);
		}
	}
	catch(exception &e) {
		cout << "메모리 부족: " << e.what() << endl;
		cout << "v의 원소 수: " << v.size() << endl;
	}

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 3:06:28
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// Container - deque
// - vector와 list의 중간 형태인 자료구조
//=======================================================================

#include <iostream>
#include <deque>
#include <vector>
#include <list>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] 어느 컨테이너가 더 많은 int를 저장할 수 있나 (benchmark)
// x86 모드에서 실행

// vector<int> v			// 최대 원소 수 - 136216567
// deque<int> v;			// 최대 원소 수 - 268435452
// list<int> v;				// 최대 원소 수 - 84066305

// list는 저장할 객체의 size가 클수록 유리하다

//--------
int main()
//--------
{
	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-04-17 월요일 오후 3:18:16
======================================================

//=======================================================================
// 2023. STL. 3월 30일 목56								월56목56 (7주 1-일)
// 4.24 월(8주 2일) - 중간고사
// 중간고사 30점, 과제 30점
//-----------------------------------------------------------------------
// Sequence Container - List
//=======================================================================
#include <iostream>
#include <list>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;
extern bool 관찰;

// [문제] 파일 "list.txt"의 단어를 list<String>으로 읽어와라.
// 화면에 읽은 단어를 출력하시오.

//--------
int main()
//--------
{
	list<String> cont;
	ifstream in{ "list.txt" };
	if (!in) {
		return 0;
	}

	String s;
	while (in >> s) {
		cont.push_back(s);
	}
	for (String& s : cont) {
		cout << s << endl;
	}

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 1:49:09
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// span, mdspan()
//====================================================================

#include <iostream>
#include <span>
#include "String.h"
#include "save.h"
using namespace std;

void print(span<int>)	// 시작번지와 갯수를 갖는 객체로 변경
{

}

void print(int a[])	// []는 *로 collapse된다.
{
	// 배열의 개수는 전달되지 않는다. (시작 번지만 전달)
	for (int i = 0; i < 10; ++i) {
		cout << a[i];
	}
}

//--------
int main()
//--------
{
	int a[10]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	print(a);

	save("소스.cpp");
}

/*
span

T[N]
array<T, N>
vector<T>
string
-> contiguous memory

void(*p)();
function object -> operator()()
[](){};
-> function (generalization <-> specialization)

std::string(32~40)
-> string_view 제공 (포장)
*/

======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 1:50:41
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// span, mdspan()
//====================================================================

#include <iostream>
#include <span>
#include "String.h"
#include "save.h"
using namespace std;

void print(span<int> cm)	// 시작번지와 갯수를 갖는 객체로 변경
{
	for (int num : cm) {
		cout << num << " ";
	}
	cout << endl;
}

void print(int a[])	// []는 *로 collapse된다.
{
	// 배열의 개수는 전달되지 않는다. (시작 번지만 전달)
	for (int i = 0; i < 10; ++i) {
		cout << a[i];
	}
}

//--------
int main()
//--------
{
	int a[10]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	print(a);

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 1:52:27
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// span, mdspan()
//====================================================================

#include <iostream>
#include <span>
#include <vector>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;

void print(span<int> cm)	// 시작번지와 갯수를 갖는 객체로 변경
{
	for (int num : cm) {
		cout << num << " ";
	}
	cout << endl;
}

//--------
int main()
//--------
{
	int a[10]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	print(a);

	vector<int> v{10, 333};
	print(v);

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 1:53:28
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// span, mdspan()
//====================================================================

#include <iostream>
#include <span>
#include <vector>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;

void print(span<int> cm)	// 시작번지와 갯수를 갖는 객체로 변경
{
	for (int num : cm) {
		cout << num << " ";
	}
	cout << endl;
}

//--------
int main()
//--------
{
	int a[10]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	print(a);

	vector<int> v(10, 333);
	print(v);

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 1:57:40
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// span, mdspan()
//====================================================================

#include <iostream>
#include <span>
#include <vector>
#include <list>
#include <string>
#include "String.h"
#include "save.h"
using namespace std;

void print(span<char> cm)	// 시작번지와 갯수를 갖는 객체로 변경
{
	for (char c : cm) {
		cout << c << " ";
	}
	cout << endl;
}

//--------
int main()
//--------
{
	std::string s{ "hello, hello" };
	print(s);

	save("소스.cpp");
}
// list는 안됨

======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 2:50:14
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
//====================================================================

#include <iostream>
#include <iterator>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// 반복자는 클래스 객체이다. 할 수 있는 동작을 알아보자.

	// 출력 반복자 어댑터
	ostream_iterator<char> p{cout};
	*p = 'A';
	++p;
	*p = 'B';
	++p;
	*p = 'C';

	save("소스.cpp");
}

/*
container ------------------> algorithm
			unuform manner
*/

======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 2:51:17
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
//====================================================================

#include <iostream>
#include <iterator>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// 반복자는 클래스 객체이다. 할 수 있는 동작을 알아보자.

	// 출력 반복자 어댑터
	ostream_iterator<int> p{cout};
	*p = 'A';
	++p;
	*p = 'B';
	++p;
	*p = 'C';

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 2:51:51
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
//====================================================================

#include <iostream>
#include <iterator>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// 반복자는 클래스 객체이다. 할 수 있는 동작을 알아보자.

	// 출력 반복자 어댑터
	ostream_iterator<int> p{cout};
	*p = 'a';
	++p;
	*p = 'b';
	++p;
	*p = 'c';

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 2:52:20
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
//====================================================================

#include <iostream>
#include <iterator>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// 반복자는 클래스 객체이다. 할 수 있는 동작을 알아보자.

	// 출력 반복자 어댑터
	ostream_iterator<char> p{cout};
	*p = 'a';
	++p;
	*p = ' ';
	++p;
	*p = 'b';
	++p;
	*p = 'c';

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 2:56:20
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// *, ++, 
//====================================================================

#include <iostream>
#include <iterator>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// 반복자는 클래스 객체이다. 할 수 있는 동작을 알아보자.

	// 출력 반복자 어댑터
	ostream_iterator<char> p{cout};
	*p = 'a';
	++p;

	(p.operator*()).operator=('a');
	p.operator++();
	// --p는 안됨


	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 2:58:10
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//====================================================================

#include <iostream>
#include <iterator>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// 반복자는 클래스 객체이다. 할 수 있는 동작을 알아보자.

	// 출력 반복자 어댑터
	ostream_iterator<char> p{cout};
	*p = 'a';
	++p;

	(p.operator*()).operator=('a');
	p.operator++();
	// --p는 안됨
	// 출력 반복자 어댑터는 조상 class (자식으로 갈수록 기능 늘어남)


	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 2:58:53
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//====================================================================

#include <iostream>
#include <iterator>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// 반복자는 클래스 객체이다. 할 수 있는 동작을 알아보자.

	// 출력 반복자 어댑터
	ostream_iterator<char> p{cout};

	p = 'a';
	p = 'b';
	p = 'c';


	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 3:00:31
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//====================================================================

#include <iostream>
#include <iterator>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// 반복자는 클래스 객체이다. 할 수 있는 동작을 알아보자.

	// 출력 반복자 어댑터
	ostream_iterator<char> p{cout};

	p = 'a';
	p = 'b';
	p = 'c';
	// 출력 반복자는 자동으로 함

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-01 월요일 오후 3:15:52
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//====================================================================

#include <iostream>
#include <iterator>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// [문제] f()는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면 출력한다

template <class 반복자>
void f( 반복자 iter )
{
	cout << typeid(iter).name() << endl;

}
//--------
int main()
//--------
{
	vector<int> v;
	ostream_iterator<char> p{ cout };

	f(v.begin());
	f(p);

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 1:34:58
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//====================================================================

#include <iostream>
#include <iterator>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// [문제] f()는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면 출력한다
// 전달된 인자가 원하는 타입인지 판단하는 - type_traits

template <class 반복자>
void f( 반복자 iter )
{
	cout << typeid(iter).name() << endl;

}
//--------
int main()
//--------
{
	vector<int> v;
	ostream_iterator<char> p{ cout };

	f(1234);
	f(v.begin());
	f(p);

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 1:36:20
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//====================================================================

#include <iostream>
#include <iterator>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// [문제] f()는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면 출력한다
// 전달된 인자가 원하는 타입인지 판단하는 - type_traits

template <class 반복자>
void f( 반복자 iter )
{
	cout << typeid(iter).name() << endl;

}
//--------
int main()
//--------
{
	vector<int> v;			// data structure
	auto p = v.begin();		// p는 v가 제공하는 iterator

	f(p);

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 1:43:33
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//====================================================================

#include <iostream>
#include <iterator>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// [문제] f()는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면 출력한다
// 전달된 인자가 원하는 타입인지 판단하는 - type_traits

template <class 반복자>
void f( 반복자 iter )
{
	cout << typeid(반복자::iterator_category).name() << endl;

}
//--------
int main()
//--------
{
	vector<int> v;			// data structure
	auto p = v.begin();		// p는 v가 제공하는 iterator

	f(p);

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 1:53:31
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//====================================================================

#include <iostream>
#include <iterator>
#include <vector>
#include <forward_list>
#include <list>
#include <deque>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// [문제] f()는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면 출력한다
// 전달된 인자가 원하는 타입인지 판단하는 - type_traits

template <class 반복자>
void f( 반복자 iter )
{
	cout << typeid(반복자::iterator_category).name() << endl;
}

//--------
int main()
//--------
{
	f(istream_iterator<char>{cin});
	f(ostream_iterator<char>{cout});
	f(forward_list<char>{}.begin());
	f(list<int>::iterator{});
	f(deque<int>::const_iterator());
	f(vector<int>::iterator());

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 1:56:32
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//====================================================================

#include <iostream>
#include <iterator>
#include <vector>
#include <forward_list>
#include <list>
#include <deque>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// [문제] f()는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면 출력한다
// 전달된 인자가 원하는 타입인지 판단하는 - type_traits

template <class 반복자>
void f( 반복자 iter )
{
	cout << typeid(반복자::iterator_category).name() << endl;
	cout << typeid(반복자::iterator_concept).name() << endl;
}

//--------
int main()
//--------
{
	f(vector<int>::iterator());

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 2:12:56
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// 프로그래밍 할 때 여러 자료구조를 같은 방법으로 사용하기 위함
// 6가지 종류(category)로 나뉜다.
// 입력/출력/전진(전방향)/양방향(전후진)/랜덤액세스/컨티구어스 반복자
// 반복자가 할 수 있는 동작
// 기초 동작: *, ++, =
//====================================================================

#include <iostream>
#include <iterator>
#include <vector>
#include <forward_list>
#include <list>
#include <deque>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// [문제] f()는 반복자를 인자로 받아 어떤 종류의 반복자인지 화면 출력한다
// 전달된 인자가 원하는 타입인지 판단하는 - type_traits

template <class 반복자>
void f( 반복자 iter )
{
	cout << typeid(iterator_traits<반복자>::iterator_category).name() << endl;
}

//--------
int main()
//--------
{
	int* p;
	f(p);

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 2:39:44
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
//====================================================================

#include <iostream>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "1234567890" };
	auto p = s.begin();
	for (auto p = s.begin(); p != s.end(); ++p) {
		cout << *p << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 2:40:45
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
//====================================================================

#include <iostream>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "1234567890" };
	
	for (char c : s) {
		cout << c << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 2:44:14
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
//====================================================================

#include <iostream>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "1234567890" };
	
	// [문제] s를 역순으로 출력하라.
	for (auto p = s.end() - 1; p != s.begin() - 1; --p) {
		cout << *p << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 2:48:53
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
//====================================================================

#include <iostream>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "1234567890" };
	
	// [문제] s를 역순으로 출력하라.
	char* p = s.end() - 1;
	for (int i = 0; i < s.size(); ++i) {
		cout << *p-- << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 2:50:58
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
//====================================================================

#include <iostream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "1234567890" };
	
	// [문제] s를 역순으로 출력하라.
	reverse(s.begin(), s.end());
	for (char c : s) {
		cout << c << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 2:54:07
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
//====================================================================

#include <iostream>
#include <algorithm>
#include <span>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "1234567890" };
	
	// [문제] s를 역순으로 출력하라.
	span<char> ss{ s.begin(), s.end() };

	for (auto p = ss.rbegin(); p != ss.rend(); ++p) {
		cout << *p << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-04 목요일 오후 3:18:50
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
//====================================================================

#include <iostream>
#include <algorithm>
#include <span>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "1234567890" };
	
	// [문제] s를 역순으로 출력하라.
	// 다음 문장이 그대로 실행되어야 한다.
	// p가 클래스 객체일 때만 가능

	for (auto p = s.rbegin(); p != s.rend(); ++p) {
		cout << *p << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-08 월요일 오후 1:47:29
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
// rbegin(), rend() -> 반드시 class로 구현해야만 한다.
//					   반복자 adaptor: 반복자처럼 행동하는 객체
//====================================================================

#include <iostream>
#include <algorithm>
#include <span>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "1234567890" };
	


	save("소스.cpp");
}
/*

목표: String이 STL의 표준 컨테이너처럼 작동하도록 제작하는 것.
String - 24byte (글자 수 8, ointer 8, 고유번호 8);

begin(), end() 반복자들이 해야할 역할을 수행하도록 coding하겠다.
rbegin(), rend()는 class로 coding하지 않으면 안 된다.


*/

======================================================
소스.cpp, 저장시간: 2023-05-08 월요일 오후 2:02:29
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
// rbegin(), rend() -> 반드시 class로 구현해야만 한다.
//					   반복자 adaptor: 반복자처럼 행동하는 객체
//====================================================================

#include <iostream>
#include <algorithm>
#include <span>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "1234567890" };
	
	// String이 제공하는 반복자의 종류는?

	for (char c : s) {
		cout << c << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-08 월요일 오후 2:03:08
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
// rbegin(), rend() -> 반드시 class로 구현해야만 한다.
//					   반복자 adaptor: 반복자처럼 행동하는 객체
//====================================================================

#include <iostream>
#include <algorithm>
#include <span>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "abcde" };
	
	// String이 제공하는 반복자의 종류는?

	for (char c : s) {
		c = toupper(c);
		cout << c << ' ';
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-08 월요일 오후 2:16:41
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
// rbegin(), rend() -> 반드시 class로 구현해야만 한다.
//					   반복자 adaptor: 반복자처럼 행동하는 객체
//====================================================================

#include <iostream>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	String s{ "abcde" };
	
	// String이 제공하는 반복자의 종류는?
	cout << typeid(String_iterator::iterator_category).name() << endl;


	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-08 월요일 오후 2:33:48
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
// rbegin(), rend() -> 반드시 class로 구현해야만 한다.
//					   반복자 adaptor: 반복자처럼 행동하는 객체
//====================================================================

#include <iostream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	std::string s{ "The quick brown fox jumps over the lazy dog" };
	
	sort(s.begin(), s.end());
	cout << s << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-08 월요일 오후 2:59:30
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
// rbegin(), rend() -> 반드시 class로 구현해야만 한다.
//					   반복자 adaptor: 반복자처럼 행동하는 객체
//====================================================================

#include <iostream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	String s{ "The quick brown fox jumps over the lazy dog" };
	
	sort(s.begin(), s.end());
	cout << s << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-08 월요일 오후 3:04:55
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
// rbegin(), rend() -> 반드시 class로 구현해야만 한다.
//					   반복자 adaptor: 반복자처럼 행동하는 객체
//====================================================================

#include <iostream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	String s{ "The quick brown fox jumps over the lazy dog" };
	
	sort(s.begin(), s.end());
	cout << s << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 1:40:14
======================================================

//====================================================================
// 2023. STL. 5월 1일 목56							월56목56 (9주 2일)
//--------------------------------------------------------------------
// 반복자 (iterator) - 포인터를 일반화(추상화)한 것이 반복자이다.
// String을 표준 컨테이너로 -> 반복자를 제공해 줘야 한다
// begin(), end()
// rbegin(), rend() -> 반드시 class로 구현해야만 한다.
//					   반복자 adaptor: 반복자처럼 행동하는 객체
//====================================================================

#include <iostream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	String s{ "The quick brown fox jumps over the lazy dog" };
	
	sort(s.begin(), s.end());
	cout << s << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 1:46:41
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
//
//====================================================================

#include <iostream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	String s{ "The quick brown fox jumps over the lazy dog" };
	transform(s.begin(), s.end(), s.begin(), [](char c) {
		return toupper(c);
		});

	cout << s;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 2:10:27
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
//
//====================================================================
#include <iostream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class 반복자, class 찾을값>
반복자 my_find(반복자 begin, 반복자 end, 찾을값 value)
{
	while (begin != end) {
		if (*begin == value) {
			return begin;
		}
		++begin;
	}
	return begin;
}

//--------
int main()
//--------
{
	String s{ "The quick brown fox jumps over 12345 the lazy dog" };

	// [문제] s중에 숫자가 있는지 찾고 싶다
	auto p = find_if(s.begin(), s.end(), [](char c) {
		return isdigit(c);
		});
	if (p == s.end()) {
		cout << "숫자 없다" << endl;
	}
	else {
		cout << distance(s.begin(), p) + 1 << "번쩨 문자는 숫자" << endl;
	}


	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 2:16:13
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
//
//====================================================================
#include <iostream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class 반복자, class 조건>
반복자 my_find_if(반복자 begin, 반복자 end, 조건 predicate)
{
	while (begin != end) {
		if (predicate(*begin)) {
			return begin;
		}
		++begin;
	}
	return begin;
}

//--------
int main()
//--------
{
	String s{ "The quick brown fox jumps over 12345 the lazy dog" };

	// [문제] s중에 숫자가 있는지 찾고 싶다
	auto p = my_find_if(s.begin(), s.end(), [](char c) {
		return isdigit(c);
		});
	if (p == s.end()) {
		cout << "숫자 없다" << endl;
	}
	else {
		cout << distance(s.begin(), p) + 1 << "번쩨 문자는 숫자" << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 2:37:44
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
//
//====================================================================
#include <iostream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	String s{ "0123456789" };

	copy(s.begin(), s.end(), ostream_iterator<char>{cout, " - "});
	
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 2:39:43
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
//
//====================================================================
#include <iostream>
#include <algorithm>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	String s{ "0123456789" };
	vector<char> v;
	v.reserve(s.size());

	copy(s.begin(), s.end(), v.begin());
	
	for (char c : v) {
		cout << c << " - ";
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 2:41:08
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
//
//====================================================================
#include <iostream>
#include <algorithm>
#include <vector>
#include <array>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	String s{ "0123456789" };
	//vector<char> v;
	//v.reserve(s.size());
	array<char, 10> v;

	copy(s.begin(), s.end(), v.begin());
	
	for (char c : v) {
		cout << c << " - ";
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 2:49:02
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
//
//====================================================================
#include <iostream>
#include <algorithm>
#include <vector>
#include <array>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter, class OutIter>
void my_copy(Iter begin, Iter end, OutIter out) {
	while (begin != end) {
		*out = *begin;
		++out;
		++begin;
	}
}

//--------
int main()
//--------
{
	String s{ "0123456789" };
	//vector<char> v;
	//v.reserve(s.size());
	array<char, 10> v;

	my_copy(s.begin(), s.end(), v.begin());
	
	for (char c : v) {
		cout << c << " - ";
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 2:56:51
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
//
//====================================================================
#include <iostream>
#include <algorithm>
#include <vector>
#include <array>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter, class OutIter>
void my_copy(Iter begin, Iter end, OutIter out) {
	while (begin != end) {
		*out = *begin;
		++out;
		++begin;
	}
}

//--------
int main()
//--------
{
	String s{ "0123456789" };
	vector<char> v;
	v.reserve(s.size());

	my_copy(s.begin(), s.end(), back_inserter(v));
	
	for (char c : v) {
		cout << c << " - ";
	}
	cout << endl;

	save("소스.cpp");
}

/*
3대 iterator adopter
1. reverse_iterator
2. istream, otream_iterator
3. inserter


*/

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 2:57:00
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
//
//====================================================================
#include <iostream>
#include <algorithm>
#include <vector>
#include <array>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter, class OutIter>
void my_copy(Iter begin, Iter end, OutIter out) {
	while (begin != end) {
		*out = *begin;
		++out;
		++begin;
	}
}

//--------
int main()
//--------
{
	String s{ "0123456789" };
	vector<char> v;
	//v.reserve(s.size());

	my_copy(s.begin(), s.end(), back_inserter(v));
	
	for (char c : v) {
		cout << c << " - ";
	}
	cout << endl;

	save("소스.cpp");
}

/*
3대 iterator adopter
1. reverse_iterator
2. istream, otream_iterator
3. inserter


*/

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 3:03:40
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map
// Set: key = value
// map: key != value 
//====================================================================
#include <iostream>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 3:12:44
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map
//====================================================================
#include <iostream>
#include <set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// String을 길이 오름차순으로 정렬하는 컨테이너
	set<String> s{ "1", "333", "22", "55555", "4444" };

	for (const String& s : s) {
		cout << s << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 3:13:06
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map
//====================================================================
#include <iostream>
#include <set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// String을 길이 오름차순으로 정렬하는 컨테이너
	set<String> s{ "2", "111", "22", "55555", "4444" };

	for (const String& s : s) {
		cout << s << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 3:16:36
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map
//====================================================================
#include <iostream>
#include <set>
#include <fstream>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// "소스.cpp"를 s에 저장
	ifstream in{ "소스.cpp" };

	set<String> s{ istream_iterator<String>{in}, {} };

	for (const String& s : s) {
		cout << s << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-11 목요일 오후 3:17:24
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map
//====================================================================
#include <iostream>
#include <set>
#include <fstream>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// "소스.cpp"를 s에 저장
	ifstream in{ "소스.cpp" };

	multiset<String> s{ istream_iterator<String>{in}, {} };
	
	for (const String& s : s) {
		cout << s << endl;
	}

	save("소스.cpp");
}
// 일반 set은 정렬기준이 길이라 길이가 같은 단어 중복 안됨

======================================================
소스.cpp, 저장시간: 2023-05-15 월요일 오후 1:49:12
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
//====================================================================
#include <iostream>
#include <set>
#include <fstream>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{

	save("소스.cpp");
}

/*
중복 미허용
보통 red-black tree로 구현
uniqueness는 equivalence relation로 결정된다
!comp(a, b) 가 성립된다면 결정

-

set<int, less<int>> s{1, 2, 3};
s.insert(3); ----------------------> 거부
				equivelent (동등)

		3(set) < 3 ---> false
		3 < 3(set) ---> false
	less로 평가
*/

======================================================
소스.cpp, 저장시간: 2023-05-15 월요일 오후 2:09:57
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// set에 정렬 기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다. - 길이순 정렬
// 2. struct less를 특수화 한다.			- 사전식 정렬
// 3. 호출 가능 객체를 직접 전달			- 영문자 먼저
//====================================================================
#include <iostream>
#include <set>
#include <fstream>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template <>
struct less<String> {
	// 사전식 정렬
	bool operator()(const String& a, const String& b) const {
		return a.getString() < b.getString();
	}
};

struct 영문자우선
{
	bool operator()(const String& a, const String& b) const {
		if (!isalpha(*(a.begin()))) {
			if (isalpha(*(b.begin()))) {
				return false;
			}
		}
		return true;
	}
};

//--------
int main()
//--------
{
	// "소스.cpp"를 s에 저장
	ifstream in{ "소스.cpp" };

	set<String, less<String>> s{ istream_iterator<String>{in}, {} };

	for (const String& s : s) {
		cout << s << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-15 월요일 오후 2:17:18
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// set에 정렬 기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다. - 길이순 정렬
// 2. struct less를 특수화 한다.			- 사전식 정렬
// 3. 호출 가능 객체를 직접 전달			- 영문자 먼저
//====================================================================
#include <iostream>
#include <set>
#include <fstream>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// "소스.cpp"를 s에 저장
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) {
		cout << "파일을 확인하시오" << endl;
		return 0;
	}
	
	multiset<String> s{ istream_iterator<String>{in}, {} };

	for (const String& s : s) {
		cout << s << endl;
	}

	cout << "단어 수 - " << s.size() << endl;
	save("소스.cpp");
}

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// set에 정렬 기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다. - 길이순 정렬
// 2. struct less를 특수화 한다.			- 사전식 정렬
// 3. 호출 가능 객체를 직접 전달			- 영문자 먼저
//====================================================================
#include <iostream>
#include <set>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) {
		cout << "파일을 확인하시오" << endl;
		return 0;
	}
	set<String> s{ istream_iterator<String>{in}, {} };
	
	// [문제] 사용자가 입력한 문자가 포함된 단어를 모두 출력하라
	while (true) {
		cout << "문자를 입력하시오: ";
		char c;
		cin >> c;

		for (const String& str : s) {
			std::string temp = str.getString();
			if (temp.contains(c)) {
				cout << temp << endl;
			}
			
			/*if (find(str.begin(), str.end(), c) != str.end()) {
				cout << str << endl;
			}*/
		}
	}
	save("소스.cpp");
}

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// set에 정렬 기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다. - 길이순 정렬
// 2. struct less를 특수화 한다.			- 사전식 정렬
// 3. 호출 가능 객체를 직접 전달			- 영문자 먼저
//====================================================================
#include <iostream>
#include <set>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) {
		cout << "파일을 확인하시오" << endl;
		return 0;
	}
	set<String> s{ istream_iterator<String>{in}, {} };
	
	// [문제] 사용자가 입력한 단어가 포함된 단어를 모두 출력하라
	while (true) {
		cout << "문자를 입력하시오: ";
		String word;
		cin >> word;

		for (const String& str : s) {
			std::string temp = str.getString();
			if (temp.contains(word.getString())) {
				cout << temp << endl;
			}
			
			/*if (find(str.begin(), str.end(), c) != str.end()) {
				cout << str << endl;
			}*/
		}
	}
	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-05-18 목요일 오후 2:05:33
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// set에 정렬 기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다. - 길이순 정렬
// 2. struct less를 특수화 한다.			- 사전식 정렬
// 3. 호출 가능 객체를 직접 전달			- 영문자 먼저
//====================================================================
#include <iostream>
#include <set>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	ifstream in{ "이상한 나라의 앨리스.txt" };
	if (!in) {
		cout << "파일을 확인하시오" << endl;
		return 0;
	}
	multiset<String> s{ istream_iterator<String>{in}, {} };
	cout << "단어 수: " << s.size() << endl;
	save("소스.cpp");
	
	// [문제] 사용자가 입력한 단어가 모두 몇 개인지 출력하라.
	// 없으면 없다고 출력하라.

	while (true) {
		cout << "문자를 입력하시오: ";
		String word;
		cin >> word;

		int cnt;
		if (cnt = s.count(word)) {
			cout << "word는 " << cnt << "개가 있습니다." << endl;
		}
		else {
			cout << "없는 단어입니다." << endl;
		}
	}
}

======================================================
소스.cpp, 저장시간: 2023-05-18 목요일 오후 2:36:33
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// set에 정렬 기준을 알려주는 방법
// 1. String의 멤버로 operator<를 정의한다. - 길이순 정렬
// 2. struct less를 특수화 한다.			- 사전식 정렬
// 3. 호출 가능 객체를 직접 전달			- 영문자 먼저
//====================================================================
#include <iostream>
#include <map>
#include <fstream>
#include <algorithm>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{


	save("소스.cpp");
	save("String.h");
	save("String.cpp");
}

======================================================
String.h, 저장시간: 2023-05-18 목요일 오후 2:36:33
======================================================

//-----------------------------------------------------------
// String.h - 자원을 확보하는 클래스
//-----------------------------------------------------------
#pragma once

using namespace std;
class ostream;
class string;

// 2023. 5. 4 추가
// String이 제공하는 역방향 반복자
class String_reverse_iterator {
	char* p;

public:
	String_reverse_iterator(char* p) : p{ p } {}

	bool operator !=(const String_reverse_iterator& rhs) const {
		return p != rhs.p;
	}
	String_reverse_iterator& operator++() {
		--p;
		return *this;
	}
	char operator*() const {
		char* t = p - 1;
		return *t;
	}
};

// 2023. 5. 8
// String이 제공하는 반복자
class String_iterator {
public:
	using iterator_conceop = contiguous_iterator_tag;
	using iterator_category = random_access_iterator_tag;
	using value_type = char;
	using difference_type = long long;
	using pointer = char*;
	using reference = char&;

private:
	char* p;

public:
	String_iterator() = default;
	String_iterator(char* p) : p{ p } {}

	char& operator *() const {
		return *p;
	}
	String_iterator& operator ++() {
		++p;
		return *this;
	}
	// sort 하려면 이 연산자들 코딩해야~
	difference_type operator -(const String_iterator& rhs) const {
		// pointer 간의 difference
		return p - rhs.p;
	}
	String_iterator& operator --() {
		--p;
		return *this;
	}
	// 2023. 5. 18 search()에서 const 선언을 요구함
	String_iterator operator +(difference_type diff) const {
		return String_iterator(p + diff);
	}
	String_iterator operator -(difference_type diff) const {
		return p - diff;;
	}

	// 관계 연산자(Relational operator), 6가지 (<, <=, >, >=, ==, !=)
	// space-ship(three-way comparator) operator로 자동화
	auto operator<=>(const String_iterator& rhs) const = default;
};

class String {
	size_t len{};
	char* p{};						//관심있으면 unique_ptr로 코딩
	size_t id = ++sid;				//객체의 고유 id

	static size_t sid;				//static 관찰할 것

public:
	String();
	String(const char* s);
	~String();

	//복사생성자/복사할당연산자
	String(const String& other);
	String& operator=(const String& other);

	//이동생성자/이동할당연산자
	// 이동이 안전함을 보증 - noexcept
	String(String&& other)noexcept;
	String& operator=(String&& other)noexcept;

	//연산자 오버로딩 함수들
	String operator+(const String& rhs) const;

	//이항연산자
	bool operator==(const String& rhs)const;


	friend std::ostream& operator<<(std::ostream& os, const String& str) {
		for (int i = {};i < str.len;++i)
			os << str.p[i];
		return os;
	}

	friend std::istream& operator>>(std::istream& is, String& s) {
		std::string str;
		is >> str;
		delete[] s.p;
		s.len = str.size();
		s.p = new char[s.len];
		memcpy(s.p,str.data(), s.len);
		return is;
	}

	// 표준 컨테이너가 되기 위한 추가 함수들 (2023. 5. 8 추가)
	String_iterator begin();
	String_iterator end();
	String_reverse_iterator rbegin();
	String_reverse_iterator rend();
	String_iterator begin() const;
	String_iterator end() const;
	
	// 2023. 5. 11 추가
	// string을 set의 원소가 되려면 < 연산자를 정의해야 한다.
	// <연산자 정렬하기 위해 필요한 기본연산자
	bool operator< (const String& rhs) const;

	// gettor
	std::string getString() const;
	void print(const char* msg) const;
	size_t size() const;
};

======================================================
String.cpp, 저장시간: 2023-05-18 목요일 오후 2:36:33
======================================================

//-----------------------------------------------------------
// String.cpp - 자원을 확보하는 클래스
//-----------------------------------------------------------

#include <iostream>
#include <string>
#include <algorithm>
#include "String.h"

extern bool 관찰{ false };			//관찰하려면 true로 바꿀 것

String::String()
{
	print("디폴트생성");
}

String::String(const char* s) :len{ strlen(s) }
{
	p = new char[len];
	memcpy(p, s, len);
	print("생성(char*)");
}

String::~String()
{
	print("소멸");
	delete[] p;
}

String::String(const String& other)
{
	len = other.len;
	p = new char[len];
	memcpy(p, other.p, len);
	print("복사생성자");
}

String& String::operator=(const String& other)
{
	if (this == &other)			// 자기자신을 할당할 이유는 없다
		return *this;

	delete[] p;

	len = other.len;
	p = new char[len];
	memcpy(p, other.p, len);

	print("복사할당연산자");
	return *this;

}


String::String(String&& other)noexcept
{
	len = other.len;
	p = other.p;

	// 이동된 객체를 초기화
	other.len = 0;
	other.p = nullptr;

	print("이동생성자");
}

String& String::operator=(String&& other)noexcept
{
	if (this == &other)
		return *this;

	// 이미 할당한 자원을 반환
	delete[] p;

	// other의 자원을 이동
	len = other.len;
	p = other.p;

	// other의 자원을 초기화
	other.len = 0;
	other.p = nullptr;

	print("이동할당연산자");
	return *this;
}


String String::operator+(const String& rhs) const
{

	String temp{};

	temp.len = len + rhs.len;
	temp.p = new char[temp.len];

	memcpy(temp.p, p, len);
	memcpy(temp.p + len, rhs.p, rhs.len);

	return temp;
}


bool String::operator==(const String& rhs)const
{
	// 길이가 같고 내용도 같아야
	return std::equal(p, p + len, rhs.p, rhs.p + rhs.len);
}

std::string String::getString()const
{
	return std::string(p,len);
}

void String::print(const char* msg) const
{
	if (관찰) {
		std::cout << "[" << id << "] - " << msg << ", 개수:" << len
			<< ", 주소:" << (void*)p << std::endl;
	}
}

size_t String::size()const
{
	return len;
}

size_t String::sid = 0;

String_iterator String::begin()
{
	return p;
}

String_iterator String::end()
{
	return p + len;
}

String_iterator String::begin() const
{
	return p;
}

String_iterator String::end() const
{
	return p + len;
}

String_reverse_iterator String::rbegin()
{
	return String_reverse_iterator{ p + len };
}

String_reverse_iterator String::rend()
{
	return String_reverse_iterator{ p };
}

// 2023. 5. 11 추가
// string을 set의 원소가 되려면 < 연산자를 정의해야 한다.
// <연산자 정렬하기 위해 필요한 기본연산자
bool String::operator< (const String& rhs) const 
{
	return getString() < rhs.getString();
}

======================================================
소스.cpp, 저장시간: 2023-05-18 목요일 오후 2:48:24
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
// 
//====================================================================
#include <iostream>
#include <map>
#include <list>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// K-POP 그룹과 멤버들을 map으로 관리
	map<String, list<String>, less<String>> kpop{ {"아이브", {"장원영", "얀유진", "레이"}}};
	kpop.insert({"아이들", {"소연", "슈화", "민니"} });

	for (auto [그룹명, 멤버들] : kpop) {
		cout << 그룹명 << " | ";
		for (const String& 멤버 : 멤버들) {
			cout << 멤버 << " ";
		}
		cout << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-18 목요일 오후 2:58:17
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
// 
//====================================================================
#include <iostream>
#include <map>
#include <list>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// K-POP 그룹과 멤버들을 map으로 관리
	map<String, list<String>, less<String>> kpop{ {"아이브", {"장원영", "얀유진", "레이"}}};
	kpop.insert({"아이들", {"소연", "슈화", "민니"} });

	for (auto [그룹명, 멤버들] : kpop) {
		cout << 그룹명 << " | ";
		for (const String& 멤버 : 멤버들) {
			cout << 멤버 << " ";
		}
		cout << endl;
	}

	list<String>& 멤버들 = kpop["아이브"];
	멤버들.insert(멤버들.begin(), {"가을", "이서", "리즈"});

	for (auto [그룹명, 멤버들] : kpop) {
		cout << 그룹명 << " | ";
		for (const String& 멤버 : 멤버들) {
			cout << 멤버 << " ";
		}
		cout << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-18 목요일 오후 2:58:41
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
// 
//====================================================================
#include <iostream>
#include <map>
#include <list>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// K-POP 그룹과 멤버들을 map으로 관리
	map<String, list<String>, less<String>> kpop{ {"아이브", {"장원영", "얀유진", "레이"}}};
	kpop.insert({"아이들", {"소연", "슈화", "민니"} });

	for (auto [그룹명, 멤버들] : kpop) {
		cout << 그룹명 << " | ";
		for (const String& 멤버 : 멤버들) {
			cout << 멤버 << " ";
		}
		cout << endl;
	}

	list<String> 멤버들 = kpop["아이브"];
	멤버들.insert(멤버들.begin(), {"가을", "이서", "리즈"});

	for (auto [그룹명, 멤버들] : kpop) {
		cout << 그룹명 << " | ";
		for (const String& 멤버 : 멤버들) {
			cout << 멤버 << " ";
		}
		cout << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-18 목요일 오후 3:06:31
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
// 
//====================================================================
#include <iostream>
#include <map>
#include <list>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// K-POP 그룹과 멤버들을 map으로 관리
	map<String, list<String>, less<String>> kpop{ {"아이브", {"장원영", "얀유진", "레이"}}};
	kpop.insert({"아이들", {"소연", "슈화", "민니"} });

	for (auto [그룹명, 멤버들] : kpop) {
		cout << 그룹명 << " | ";
		for (const String& 멤버 : 멤버들) {
			cout << 멤버 << " ";
		}
		cout << endl;
	}

	list<String>& 멤버들 = kpop["아이브"];
	멤버들.insert(멤버들.begin(), {"가을", "이서", "리즈"});

	// const인 노드 이름을 변경하는 기능 - extract 멤버(C++17)
	auto handle = kpop.extract("아이브");
	handle.key() = "IVE";
	kpop.insert(move(handle));


	for (auto [그룹명, 멤버들] : kpop) {
		cout << 그룹명 << " | ";
		for (const String& 멤버 : 멤버들) {
			cout << 멤버 << " ";
		}
		cout << endl;
	}

	save("소스.cpp");
}

/*
아이브 - ㅁ - ㅁ - ㅁ - ㅁ
아이들 - ㅁ - ㅁ - ㅁ - ㅁ
> 그룹 부분은 키값
c++17부터 키값을 extract 해서 key를 수정할 수 있는 기능이 생겼다


*/

======================================================
소스.cpp, 저장시간: 2023-05-18 목요일 오후 3:12:33
======================================================

//====================================================================
// 2023. STL. 5월 11일 목56							월56목56 (11주 1일)
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
// 
//====================================================================
#include <iostream>
#include <map>
#include <list>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// [문제] 소설에서 각 문자가 사용된 횟수를 출력하라.
	ifstream in{ "이상한 나라의 앨리스.txt" };
	
	map<char, int> cim;

	char c;
	while (in >> c) {
		cim[c]++;
	}

	for (auto [문자, 개수] : cim) {
		cout << 문자 << ": " << 개수 << endl;
	}

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 1:38:38
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
//====================================================================
#include <iostream>
#include <map>
#include <list>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// [문제] 소설에서 각 문자가 사용된 횟수를 출력하라.
	ifstream in{ "이상한 나라의 앨리스.txt" };
	
	map<char, int> cim;

	char c;
	while (in >> c) {
		if (isalpha(c)) {
			cim[tolower(c)]++;
		}
	}

	// [문제] 많이 사용된 문자 순으로 출력하라.
	for (auto [문자, 개수] : cim) {			// structured binding
		cout << 문자 << ": " << 개수 << endl;
	}

	save("소스.cpp");
}
/*
set[key]; -> &value;
있으면 search, 없으면 추가

*/

======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 1:44:22
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
//====================================================================
#include <iostream>
#include <map>
#include <vector>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// [문제] 소설에서 각 문자가 사용된 횟수를 출력하라.
	ifstream in{ "이상한 나라의 앨리스.txt" };
	
	map<char, int> cim;

	char c;
	while (in >> c) {
		if (isalpha(c)) {
			cim[tolower(c)]++;
		}
	}

	// cim의 원소를 vector로 복사
	vector<pair<char, int>> v{ cim.begin(), cim.end() };

	sort(v.begin(), v.end(), [](const auto& a, const auto& b) {
		return a.second > b.second;
		});

	// [문제] 많이 사용된 문자 순으로 출력하라.
	for (auto [문자, 개수] : v) {			// structured binding
		cout << 문자 << ": " << 개수 << endl;
	}

	save("소스.cpp");
}
/*
set[key]; -> &value;
있으면 search, 없으면 추가

*/

======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 1:51:26
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
//====================================================================
#include <iostream>
#include <map>
#include <vector>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// [문제] 소설에서 각 단어가 사용된 횟수 기준 내림차순으로 출력하라.
	ifstream in{ "이상한 나라의 앨리스.txt" };
	
	map<std::string, int> cim;

	std::string c;
	while (in >> c) {
		cim[c]++;
	}

	// cim의 원소를 vector로 복사
	vector<pair<std::string, int>> v{ cim.begin(), cim.end() };

	sort(v.begin(), v.end(), [](const auto& a, const auto& b) {
		return a.second > b.second;
		});

	// [문제] 많이 사용된 문자 순으로 출력하라.
	for (auto [문자, 개수] : v) {			// structured binding
		cout << 문자 << ": " << 개수 << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 1:54:31
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
//====================================================================
#include <iostream>
#include <map>
#include <vector>
#include <fstream>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// [문제] 소설에서 각 단어가 사용된 횟수 기준 내림차순으로 출력하라.
	ifstream in{ "이상한 나라의 앨리스.txt" };
	
	map<String, int> cim;

	String c;
	while (in >> c) {
		cim[c]++;
	}

	map<int, String> iSm;
	for (auto [단어, 개수] : cim) {
		iSm[개수] = 단어;
	}
	for (auto [개수, 단어] : iSm) {
		cout << 단어 << ": " << 개수 << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 1:55:40
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
//====================================================================
#include <iostream>
#include <map>
#include <vector>
#include <fstream>
#include <algorithm>
#include <ranges>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// [문제] 소설에서 각 단어가 사용된 횟수 기준 내림차순으로 출력하라.
	ifstream in{ "이상한 나라의 앨리스.txt" };
	
	map<String, int> cim;

	String c;
	while (in >> c) {
		cim[c]++;
	}

	map<int, String> iSm;
	for (auto [단어, 개수] : cim) {
		iSm[개수] = 단어;
	}
	for (auto [개수, 단어] : iSm | views::reverse) {
		cout << 단어 << ": " << 개수 << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 1:57:06
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
//====================================================================
#include <iostream>
#include <map>
#include <vector>
#include <fstream>
#include <algorithm>
#include <ranges>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// [문제] 소설에서 각 단어가 사용된 횟수 기준 내림차순으로 출력하라.
	ifstream in{ "이상한 나라의 앨리스.txt" };
	
	map<String, int> cim;

	String c;
	while (in >> c) {
		cim[c]++;
	}

	map<int, String> iSm;
	for (auto [단어, 개수] : cim) {
		iSm[개수] = 단어;
	}
	for (auto [개수, 단어] : iSm | views::reverse) {
		cout << 단어 << ": " << 개수 << endl;
	}
	cout << "원소 수: " << cim.size() << endl;
	cout << "원소 수: " << iSm.size() << endl;

	save("소스.cpp");
}

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
//====================================================================
#include <iostream>
#include <map>
#include <vector>
#include <fstream>
#include <algorithm>
#include <ranges>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	// [문제] 소설에서 각 단어가 사용된 횟수 기준 내림차순으로 출력하라.
	ifstream in{ "이상한 나라의 앨리스.txt" };
	
	multimap<String, int> cim;

	String c;
	while (in >> c) {
		cim[c]++;
	}

	map<int, String> iSm;
	for (auto [단어, 개수] : cim) {
		// iSm.insert(pair<int, String>{개수, 단어});
		iSm.insert(make_pair(개수, 단어));
	}
	for (auto [개수, 단어] : iSm | views::reverse | views::take(200)) {
		cout << 단어 << ": " << 개수 << endl;
	}
	cout << "원소 수: " << cim.size() << endl;
	cout << "원소 수: " << iSm.size() << endl;

	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 2:14:25
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Associative Container - Set, map - 원소의 같음을 equivalence로 평가
//									- 동등성 / 상등성
// map은 pair<key, value>를 원소로 갖는다
//====================================================================
#include <iostream>
#include <set>
#include <random>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{ 1, 99'999 };

//--------
int main()
//--------
{
	int a[10]{};
	for (int i = 0; i < 100'0000; ++i) {
		int num = uid(dre);
		a[num / 10000]++;
	}

	// [문제] 숫자를 10구간으로 나눠 개수를 세서 출력하라.
	for (int i = 0; i < 10; ++i) {
		cout << "[" << 0 + i * 10000 << ", " << 9999 + i * 10000 << "] - " << a[i] << endl;
	}
	// [0, 9999] - 
	// [10000, 19999] -
	// ...
	// [90000, 99999] - 

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 2:47:25
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Unordered Associative Container
// 순서가 없다는 것의 의미
// 메모리 구조를 이해해 본다
// String을 원소로 담으려면? - hash 함수를 제공
//====================================================================
#include <iostream>
#include <set>
#include <random>
#include <unordered_set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	unordered_set<int> us{ 2, 4, 1, 3 };
	for (int n : us) {
		cout << n << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

/*
linear 0(N)
set/map 0(logN)
Unordered set/map 0(1) - 탐색 시간을 위해 공간(메모리) 희생

3을 찾는다고 치면
hasher에 3이 어딨니? 하면 바로 즉답해줌

	hasher -----------> bucket -----------> 찾는 원소
방 번호 뽑아줌			vector		이중 연결 리스트로 연결됨
*/

======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 2:48:16
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Unordered Associative Container
// 순서가 없다는 것의 의미
// 메모리 구조를 이해해 본다
// String을 원소로 담으려면? - hash 함수를 제공
//====================================================================
#include <iostream>
#include <set>
#include <random>
#include <unordered_set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	unordered_set<int> us{ 2, 4, 1, 3 };

	for (int n : us) {
		cout << n << ' ';
	}
	cout << endl;

	// 원소 추가
	us.insert(10);

	for (int n : us) {
		cout << n << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

/*
linear 0(N)
set/map 0(logN)
Unordered set/map 0(1) - 탐색 시간을 위해 공간(메모리) 희생

3을 찾는다고 치면
hasher에 3이 어딨니? 하면 바로 즉답해줌

	hasher -----------> bucket -----------> 찾는 원소
방 번호 뽑아줌			vector		이중 연결 리스트로 연결됨
*/

======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 2:48:53
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Unordered Associative Container
// 순서가 없다는 것의 의미
// 메모리 구조를 이해해 본다
// String을 원소로 담으려면? - hash 함수를 제공
//====================================================================
#include <iostream>
#include <set>
#include <random>
#include <unordered_set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	unordered_set<int> us{ 1, 2, 3, 4 };

	for (int n : us) {
		cout << n << ' ';
	}
	cout << endl;

	// 원소 추가
	us.insert(10);

	for (int n : us) {
		cout << n << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

/*
linear 0(N)
set/map 0(logN)
Unordered set/map 0(1) - 탐색 시간을 위해 공간(메모리) 희생

3을 찾는다고 치면
hasher에 3이 어딨니? 하면 바로 즉답해줌

	hasher -----------> bucket -----------> 찾는 원소
방 번호 뽑아줌			vector		이중 연결 리스트로 연결됨
*/

======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 2:52:39
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Unordered Associative Container
// 순서가 없다는 것의 의미
// 메모리 구조를 이해해 본다
// String을 원소로 담으려면? - hash 함수를 제공
//====================================================================
#include <iostream>
#include <set>
#include <random>
#include <unordered_set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	unordered_set<int> us{ 1, 2, 3, 4 };

	for (int i = 0; i < us.bucket_count(); ++i) {
		cout << "[" << i << "]";
		for (auto p = us.begin(i); p != us.end(i); ++p) {
			cout << " - " << *p << ' ';
		}
		cout << endl;
	}

	save("소스.cpp");
}

/*
linear 0(N)
set/map 0(logN)
Unordered set/map 0(1) - 탐색 시간을 위해 공간(메모리) 희생

3을 찾는다고 치면
hasher에 3이 어딨니? 하면 바로 즉답해줌

	hasher -----------> bucket -----------> 찾는 원소
방 번호 뽑아줌			vector		이중 연결 리스트로 연결됨
*/

======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 2:54:08
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Unordered Associative Container
// 순서가 없다는 것의 의미
// 메모리 구조를 이해해 본다
// String을 원소로 담으려면? - hash 함수를 제공
//====================================================================
#include <iostream>
#include <set>
#include <random>
#include <unordered_set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	unordered_multiset<int> us{ 1, 2, 3, 4, 1, 1, 1 };		// 원소 개수가 늘어나면 buckets 개수 늘어난다

	for (int i = 0; i < us.bucket_count(); ++i) {
		cout << "[" << i << "]";
		for (auto p = us.begin(i); p != us.end(i); ++p) {
			cout << " - " << *p;
		}
		cout << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 3:11:18
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Unordered Associative Container
// 순서가 없다는 것의 의미
// 메모리 구조를 이해해 본다
// String을 원소로 담으려면? - hash 함수를 제공
//====================================================================
#include <iostream>
#include <set>
#include <random>
#include <unordered_set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<>
struct hash<String> {
	size_t operator()(const String& str) const {
		return hash<string>()(str.getString());
	}
};

//--------
int main()
//--------
{
	unordered_multiset<String> us{"C++", "STL", "Container", "Iterator", "Algorithm"};
	save("소스.cpp");

	while (1) {
		for (int i = 0; i < us.bucket_count(); ++i) {
			cout << "[" << i << "]";
			for (auto p = us.begin(i); p != us.end(i); ++p) {
				cout << " - " << *p;
			}
			cout << endl;
		}

		cout << "값을 입력하면 원소를 추가합니다: ";
		String str;
		cin >> str;
		us.insert(str);
	}
}

======================================================
소스.cpp, 저장시간: 2023-05-22 월요일 오후 3:13:36
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Unordered Associative Container
// 순서가 없다는 것의 의미
// 메모리 구조를 이해해 본다
// String을 원소로 담으려면? - hash 함수를 제공
//====================================================================
#include <iostream>
#include <set>
#include <random>
#include <unordered_set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<>
struct hash<String> {
	size_t operator()(const String& str) const {
		return hash<string>()(str.getString());
	}
};

//--------
int main()
//--------
{
	unordered_multiset<String> us{"C++", "STL", "Container", "Iterator", "Algorithm"};
	auto p = us.find("Algorithm");
	cout << *p << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-25 목요일 오후 1:44:10
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Container들의 찾기 실력을 검증한다. - int 천만개에서 int 만개를 탐색
// vector
// set
// unordered_set
//====================================================================
#include <iostream>
#include <random>
#include <algorithm>
#include <chrono>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

array<int, 1000'0000> numbers;
array<int, 1'0000> toFind;

default_random_engine dre;
uniform_int_distribution uid{ 1, 100'000'000 };

//--------
int main()
//--------
{
	for (int& num : numbers) {
		num = uid(dre);
	}

	for (int& num : toFind) {
		num = uid(dre);
	}

	{
		// vector에서 찾기
		vector<int> v{ numbers.begin(), numbers.end() };
		cout << "vector에서 찾는 중..." << endl;
		int cnt{};

		// 시간 재기 시작
		for (int num : toFind) {
			if (v.end() != find(v.begin(), v.end(), num)) {
				cnt++;
			}
		}

		// 시간 재기 끝
		cout << "걸린 시간: " << endl;
		cout << "찾은 개수: " << cnt;
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-25 목요일 오후 2:02:16
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Container들의 찾기 실력을 검증한다. - int 천만개에서 int 만개를 탐색
// vector
// set
// unordered_set
//====================================================================
#include <iostream>
#include <random>
#include <algorithm>
#include <chrono>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

array<int, 1000'0000> numbers;
array<int, 1'0000> toFind;

default_random_engine dre;
uniform_int_distribution uid{ 1, 100'000'000 };

//--------
int main()
//--------
{
	for (int& num : numbers) {
		num = uid(dre);
	}

	for (int& num : toFind) {
		num = uid(dre);
	}

	{
		// vector에서 찾기
		vector<int> v{ numbers.begin(), numbers.end() };
		cout << "vector에서 찾는 중..." << endl;
		int cnt{};

		// 시간 재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (v.end() != find(v.begin(), v.end(), num)) {
				cnt++;
			}
		}

		// 시간 재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();

		cout << "걸린 시간(us): " << elapsedTime << endl;
		cout << "찾은 개수:     " << cnt;
		cout << endl << endl;
	}
	
	{
		// set에서 찾기
		cout << "set에 data 넣는 중..." << endl;
		set<int> s{ numbers.begin(), numbers.end() };
		cout << "set에서 찾는 중..." << endl;
		int cnt{};

		// 시간 재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (s.contains(num)) {
				cnt++;
			}
		}

		// 시간 재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();

		cout << "걸린 시간(us): " << elapsedTime << endl;
		cout << "찾은 개수:     " << cnt;
		cout << endl << endl;
	}

	{
		// unordered_set에서 찾기
		cout << "unordered_set에 data 넣는 중..." << endl;
		unordered_set<int> us{ numbers.begin(), numbers.end() };
		cout << "unordered_set에서 찾는 중..." << endl;
		int cnt{};

		// 시간 재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (us.contains(num)) {
				cnt++;
			}
		}

		// 시간 재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();

		cout << "걸린 시간(us): " << elapsedTime << endl;
		cout << "찾은 개수:     " << cnt;
		cout << endl << endl;
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-25 목요일 오후 2:04:22
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Container들의 찾기 실력을 검증한다. - int 천만개에서 int 만개를 탐색
// vector			13.2	초
// set				0.01	초
// unordered_set	0.00046 초
//====================================================================
#include <iostream>
#include <random>
#include <algorithm>
#include <chrono>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

array<int, 1000'0000> numbers;
array<int, 1'0000> toFind;

default_random_engine dre;
uniform_int_distribution uid{ 1, 100'000'000 };

//--------
int main()
//--------
{
	for (int& num : numbers) {
		num = uid(dre);
	}

	for (int& num : toFind) {
		num = uid(dre);
	}

	{
		// vector에서 찾기
		vector<int> v{ numbers.begin(), numbers.end() };
		cout << "vector에서 찾는 중..." << endl;
		int cnt{};

		// 시간 재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (v.end() != find(v.begin(), v.end(), num)) {
				cnt++;
			}
		}

		// 시간 재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();

		cout << "걸린 시간(us): " << elapsedTime << endl;
		cout << "찾은 개수:     " << cnt;
		cout << endl << endl;
	}
	
	{
		// set에서 찾기
		cout << "set에 data 넣는 중..." << endl;
		set<int> s{ numbers.begin(), numbers.end() };
		cout << "set에서 찾는 중..." << endl;
		int cnt{};

		// 시간 재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (s.contains(num)) {
				cnt++;
			}
		}

		// 시간 재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();

		cout << "걸린 시간(us): " << elapsedTime << endl;
		cout << "찾은 개수:     " << cnt;
		cout << endl << endl;
	}

	{
		// unordered_set에서 찾기
		cout << "unordered_set에 data 넣는 중..." << endl;
		unordered_set<int> us{ numbers.begin(), numbers.end() };
		cout << "unordered_set에서 찾는 중..." << endl;
		int cnt{};

		// 시간 재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (us.contains(num)) {
				cnt++;
			}
		}

		// 시간 재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();

		cout << "걸린 시간(us): " << elapsedTime << endl;
		cout << "찾은 개수:     " << cnt;
		cout << endl << endl;
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-25 목요일 오후 2:08:48
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// Container들의 찾기 실력을 검증한다. - int 천만개에서 int 만개를 탐색
// vector			13.2	초
// set				0.01	초
// sorted vector	0.0027	초
// unordered_set	0.00046 초
//====================================================================
#include <iostream>
#include <random>
#include <algorithm>
#include <chrono>
#include <array>
#include <vector>
#include <set>
#include <unordered_set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

array<int, 1000'0000> numbers;
array<int, 1'0000> toFind;

default_random_engine dre;
uniform_int_distribution uid{ 1, 100'000'000 };

//--------
int main()
//--------
{
	for (int& num : numbers) {
		num = uid(dre);
	}

	for (int& num : toFind) {
		num = uid(dre);
	}

	{
		// vector에서 찾기
		vector<int> v{ numbers.begin(), numbers.end() };
		cout << "vector에서 찾는 중..." << endl;
		int cnt{};

		// 시간 재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (v.end() != find(v.begin(), v.end(), num)) {
				cnt++;
			}
		}

		// 시간 재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();

		cout << "걸린 시간(us): " << elapsedTime << endl;
		cout << "찾은 개수:     " << cnt;
		cout << endl << endl;
	}
	
	{
		// set에서 찾기
		cout << "set에 data 넣는 중..." << endl;
		set<int> s{ numbers.begin(), numbers.end() };
		cout << "set에서 찾는 중..." << endl;
		int cnt{};

		// 시간 재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (s.contains(num)) {
				cnt++;
			}
		}

		// 시간 재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();

		cout << "걸린 시간(us): " << elapsedTime << endl;
		cout << "찾은 개수:     " << cnt;
		cout << endl << endl;
	}

	{
		// unordered_set에서 찾기
		cout << "unordered_set에 data 넣는 중..." << endl;
		unordered_set<int> us{ numbers.begin(), numbers.end() };
		cout << "unordered_set에서 찾는 중..." << endl;
		int cnt{};

		// 시간 재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (us.contains(num)) {
				cnt++;
			}
		}

		// 시간 재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();

		cout << "걸린 시간(us): " << elapsedTime << endl;
		cout << "찾은 개수:     " << cnt;
		cout << endl << endl;
	}

	{
		// 정렬된 vector에서 찾기
		vector<int> v{ numbers.begin(), numbers.end() };
		cout << "vector를 정렬하는 중..." << endl;
		sort(v.begin(), v.end());
		cout << "vector에서 찾는 중..." << endl;
		int cnt{};

		// 시간 재기 시작
		auto start = chrono::steady_clock::now();
		for (int num : toFind) {
			if (binary_search(v.begin(), v.end(), num)) {
				cnt++;
			}
		}

		// 시간 재기 끝
		auto end = chrono::steady_clock::now();
		auto elapsedTime = chrono::duration_cast<chrono::microseconds>(end - start).count();

		cout << "걸린 시간(us): " << elapsedTime << endl;
		cout << "찾은 개수:     " << cnt;
		cout << endl << endl;
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-25 목요일 오후 2:39:13
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	vector<int> v{ 1,3,5,7,9,2,4,6,8,10 };
	sort(v.begin(), v.begin() + v.size());

	for (int n : v) {
		cout << n << ' ';
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-25 목요일 오후 2:39:27
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	vector<int> v{ 1,3,5,7,9,2,4,6,8,10 };
	ranges::sort(v.begin(), v.begin() + v.size());

	for (int n : v) {
		cout << n << ' ';
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-25 목요일 오후 2:39:48
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	vector<int> v{ 1,3,5,7,9,2,4,6,8,10 };
	ranges::sort(v);

	for (int n : v) {
		cout << n << ' ';
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-25 목요일 오후 3:12:33
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (11주 1일)
// 13주 2일 5. 29 (월) - 동영상 출석
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

//--------
int main()
//--------
{
	vector<int>v{ 1,3,5,7,9 };

	// [문제] v의 원소가 전부 홀수인지 검사한다.
	bool res = all_of(v.begin(), v.end(), [](int i) {
		return i & 1;
		});
	cout << boolalpha << "홀수? - " << res << endl;
	save("소스.cpp");
}


======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 9:21:09
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iterator, class Pred>
bool my_all_of(Iterator begin, Iterator end, Pred pred) {
	while (begin != end) {
		if (pred(*begin) == false) {
			return false;
		}
		++begin;
	}
	return true;
}

//--------
int main()
//--------
{
	vector<int>v{ 1,3,5,7,9 };

	// [문제] v의 원소가 전부 홀수인지 검사한다.
	bool res = my_all_of(v.begin(), v.end(), [](int i) {
		return i & 1;
		});
	cout << boolalpha << "홀수? - " << res << endl;
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 9:21:23
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iterator, class Pred>
bool my_all_of(Iterator begin, Iterator end, Pred pred) {
	while (begin != end) {
		if (pred(*begin) == false) {
			return false;
		}
		++begin;
	}
	return true;
}

//--------
int main()
//--------
{
	vector<int>v{ 1,3,5,7,9, 10 };

	// [문제] v의 원소가 전부 홀수인지 검사한다.
	bool res = my_all_of(v.begin(), v.end(), [](int i) {
		return i & 1;
		});
	cout << boolalpha << "홀수? - " << res << endl;
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 9:21:43
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iterator, class Pred>
bool my_all_of(Iterator begin, Iterator end, Pred pred) {
	while (begin != end) {
		if (pred(*begin) == false) {
			return false;
		}
		++begin;
	}
	return true;
}

//--------
int main()
//--------
{
	vector<int>v{};

	// [문제] v의 원소가 전부 홀수인지 검사한다.
	bool res = my_all_of(v.begin(), v.end(), [](int i) {
		return i & 1;
		});
	cout << boolalpha << "홀수? - " << res << endl;
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 9:23:52
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iterator, class Pred>
bool my_all_of(Iterator begin, Iterator end, Pred pred) {
	while (begin != end) {
		if (pred(*begin) == false) {
			return false;
		}
		++begin;
	}
	return true;
}

//--------
int main()
//--------
{
	String s{ "algorithm - all_of" };

	// [문제] s의 원소가 전부 소문자인지 검사한다.
	bool res = my_all_of(s.begin(), s.end(), [](char c) {
		return islower(c);
		});
	cout << boolalpha << "모두 소문자? - " << res << endl;
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 9:24:13
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iterator, class Pred>
bool my_all_of(Iterator begin, Iterator end, Pred pred) {
	while (begin != end) {
		if (pred(*begin) == false) {
			return false;
		}
		++begin;
	}
	return true;
}

//--------
int main()
//--------
{
	String s{ "algorithmallof" };

	// [문제] s의 원소가 전부 소문자인지 검사한다.
	bool res = my_all_of(s.begin(), s.end(), [](char c) {
		return islower(c);
		});
	cout << boolalpha << "모두 소문자? - " << res << endl;
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 9:37:10
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 컨테이너가 2개 이상 있을 때
// 첫 컨테이너는 전체 구간을 알려줘야 하고
// 두 번째 컨테이너는 구간의 시작만 알려줘도 충분하다.

//--------
int main()
//--------
{
	vector<int> v1{ 1, 2, 3, 4, 5, 6, 7 };
	vector<int> v2{ 1,2,3,4,7,8,7,9,10,20 };

	auto p = mismatch(v1.begin(), v1.end(), v2.begin());

	cout << "v1의 위치 - " << *p.first << endl;
	cout << "v2의 위치 - " << *p.second << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 9:38:26
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 컨테이너가 2개 이상 있을 때
// 첫 컨테이너는 전체 구간을 알려줘야 하고
// 두 번째 컨테이너는 구간의 시작만 알려줘도 충분하다.

//--------
int main()
//--------
{
	vector<int> v1{ 1, 2, 3, 4, 5, 6, 7 };
	vector<int> v2{ 1,2,3,4,5,6,7,8,9,10,20 };

	auto p = mismatch(v1.begin(), v1.end(), v2.begin());

	cout << "v1의 위치 - " << *p.first << endl;
	cout << "v2의 위치 - " << *p.second << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 9:39:47
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 컨테이너가 2개 이상 있을 때
// 첫 컨테이너는 전체 구간을 알려줘야 하고
// 두 번째 컨테이너는 구간의 시작만 알려줘도 충분하다.

//--------
int main()
//--------
{
	vector<int> v1{ 1, 2, 3, 4, 5, 6, 7 };
	vector<int> v2{ 1,2,3,4,5,6,7,8,9,10,20 };

	auto p = mismatch(v1.begin(), v1.end(), v2.begin());
	
	if (p.first != v1.end()) {
		cout << "v1의 위치 - " << *p.first << endl;
	}
	if (p.second != v2.end()) {
		cout << "v2의 위치 - " << *p.second << endl;
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 9:40:00
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 컨테이너가 2개 이상 있을 때
// 첫 컨테이너는 전체 구간을 알려줘야 하고
// 두 번째 컨테이너는 구간의 시작만 알려줘도 충분하다.

//--------
int main()
//--------
{
	vector<int> v1{ 1, 2, 3, 4, 5, 6, 7 };
	vector<int> v2{ 1,2,3,4,5,6 };

	auto p = mismatch(v1.begin(), v1.end(), v2.begin());
	
	if (p.first != v1.end()) {
		cout << "v1의 위치 - " << *p.first << endl;
	}
	if (p.second != v2.end()) {
		cout << "v2의 위치 - " << *p.second << endl;
	}
	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 9:47:33
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 흥미 예제 - Lotto 번호 생성기

//--------
int main()
//--------
{
	vector<int> v;
	v.reserve(45);
	for (int i = 0; i < 45; ++i) {
		v.push_back(i + 1);
	}

	for (int n : v) {
		cout << n << ' ';
	}
	cout << endl;

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 9:53:20
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 흥미 예제 - Lotto 번호 생성기

//--------
int main()
//--------
{
	vector<int> v;
	v.reserve(45);
	for (int i = 0; i < 45; ++i) {
		v.push_back(i + 1);
	}

	for (int n : v) {
		cout << n << ' ';
	}
	cout << endl << endl;

	cout << "이번 주 구입할 Lotto 번호 - ";
	sample(v.begin(), v.end(), ostream_iterator<int>{cout, " "}, 6, default_random_engine(random_device{}()));

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 9:54:06
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 흥미 예제 - Lotto 번호 생성기

//--------
int main()
//--------
{
	vector<int> v;
	v.reserve(45);
	for (int i = 0; i < 45; ++i) {
		v.push_back(i + 1);
	}

	for (int n : v) {
		cout << n << ' ';
	}
	cout << endl << endl;

	for (int i = 0; i < 100; ++i) {
		cout << "이번 주 구입할 Lotto 번호 - ";
		sample(v.begin(), v.end(), ostream_iterator<int>{cout, " "}, 6, default_random_engine(random_device{}()));
		cout << endl;
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:01:54
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 흥미 예제 - 전광판 예제

//--------
int main()
//--------
{
	String s{ "C++ STL Containers iterators Algorithms " };

	for (int i = 0; i < 10; ++i) {
		cout << s << endl;
		rotate(s.begin(), s.begin() + 1, s.end());
	}

	save("소스.cpp");
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:05:29
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <string>
#include <format>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 흥미 예제 - 전광판 예제

//--------
int main()
//--------
{
	save("소스.cpp");
	std::string s{ "C++ STL Containers iterators Algorithms " };

	for (int i = 0; i < 5; ++i) {
		cout << endl;
	}

	while (true) {
		cout << format("{:^79}", s);
		rotate(s.begin(), s.begin() + 1, s.end());
		cout << '\r';
	}

}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:07:16
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <string>
#include <format>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 흥미 예제 - 전광판 예제

//--------
int main()
//--------
{
	save("소스.cpp");
	std::string s{ "C++ STL Containers iterators Algorithms " };

	for (int i = 0; i < 5; ++i) {
		cout << endl;
	}

	while (true) {
		cout << format("{:^79}", s);
		this_thread::sleep_for(100ms);
		rotate(s.begin(), s.begin() + 1, s.end());
		cout << '\r';
	}

}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:08:02
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <string>
#include <format>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 흥미 예제 - 전광판 예제

//--------
int main()
//--------
{
	save("소스.cpp");
	std::string s{ "C++ STL Containers iterators Algorithms " };

	for (int i = 0; i < 5; ++i) {
		cout << endl;
	}

	while (true) {
		cout << format("{:^79}", s);
		this_thread::sleep_for(100ms);
		rotate(s.begin(), s.begin() - 1, s.end());
		cout << '\r';
	}

}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:08:19
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <string>
#include <format>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 흥미 예제 - 전광판 예제

//--------
int main()
//--------
{
	save("소스.cpp");
	std::string s{ "C++ STL Containers iterators Algorithms " };

	for (int i = 0; i < 5; ++i) {
		cout << endl;
	}

	while (true) {
		cout << format("{:^79}", s);
		this_thread::sleep_for(100ms);
		rotate(s.begin(), s.end() - 1, s.end());
		cout << '\r';
	}

}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:09:21
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <string>
#include <format>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 흥미 예제 - 전광판 예제

//--------
int main()
//--------
{
	save("소스.cpp");
	std::string s{ "C++ STL Containers iterators Algorithms " };

	for (int i = 0; i < 5; ++i) {
		cout << endl;
	}

	while (true) {
		cout << format("{:^79}", s);
		this_thread::sleep_for(100ms);
		shift_left(s.begin(), s.end(), 1);
		cout << '\r';
	}

}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:09:37
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <string>
#include <format>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 흥미 예제 - 전광판 예제

//--------
int main()
//--------
{
	save("소스.cpp");
	std::string s{ "C++ STL Containers iterators Algorithms " };

	for (int i = 0; i < 5; ++i) {
		cout << endl;
	}

	while (true) {
		cout << format("{:^79}", s);
		this_thread::sleep_for(100ms);
		shift_right(s.begin(), s.end(), 1);
		cout << '\r';
	}

}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:10:42
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <string>
#include <format>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 흥미 예제 - 전광판 예제

//--------
int main()
//--------
{
	save("소스.cpp");
	std::string s{ "C++ STL Containers iterators Algorithms " };

	for (int i = 0; i < 5; ++i) {
		cout << endl;
	}

	while (true) {
		cout << format("{:^79}", s);
		this_thread::sleep_for(200ms);
		rotate(s.begin(), s.begin() + 1, s.end());
		cout << '\r';
	}

}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:31:25
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <string>
#include <format>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

// 흥미 예제 - 전광판 예제

//--------
int main()
//--------
{
	save("소스.cpp");
	
	vector<int> v{ 1,2,3,4,5,6 };

	copy(v.begin(), v.end() - 1, v.begin() + 1);

	for (int n : v) {
		cout << n << ' ';
	}
	cout << endl;
}


======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:46:09
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms	- sort 관련 함수들
// partition	- 기준에 따라 분리
// nth_element	- 기준에 맞는 n개를 분리
// partial_sotr	- n개까지만 정렬
// sort			- 기준에 따라 모든 원소를 정렬 
// stable_sort	- 상대적인 순서를 변경하지 않으면서 모든 원소를 정렬
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <format>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

default_random_engine dre;

//--------
int main()
//--------
{
	save("소스.cpp");

	// 자료 준비
	vector<int> v(100);
	for (int i = 0; i < 100; ++i) {
		v[i] = i + 1;
	}

	{
		// partition - odd / even
		shuffle(v.begin(), v.end(), dre);				// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		auto p = partition(v.begin(), v.end(), [](int n) { return n % 2 == 1; });
		cout << "partition 결과" << endl;
		cout << "odd numbers" << endl;
		for (auto i = v.begin(); i != p; ++i) {
			cout << format("{:4}", *i);
		}
		cout << endl;
		cout << "even numbers" << endl;
		for (auto i = p; i != v.end(); ++i) {
			cout << format("{:4}", *i);
		}
		cout << endl;
	}
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:52:45
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms	- sort 관련 함수들
// partition	- 기준에 따라 분리
// nth_element	- 기준에 맞는 n개를 분리
// partial_sotr	- n개까지만 정렬
// sort			- 기준에 따라 모든 원소를 정렬 
// stable_sort	- 상대적인 순서를 변경하지 않으면서 모든 원소를 정렬
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <format>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

default_random_engine dre;

//--------
int main()
//--------
{
	save("소스.cpp");

	// 자료 준비
	vector<int> v(100);
	for (int i = 0; i < 100; ++i) {
		v[i] = i + 1;
	}

	{
		// partition - odd / even
		shuffle(v.begin(), v.end(), dre);				// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		auto p = partition(v.begin(), v.end(), [](int n) { return n % 2 == 1; });
		cout << "partition 결과" << endl;
		cout << endl;
		cout << "odd numbers" << endl;
		for (auto i = v.begin(); i != p; ++i) {
			cout << format("{:4}", *i);
		}
		cout << endl;
		cout << "even numbers" << endl;
		for (auto i = p; i != v.end(); ++i) {
			cout << format("{:4}", *i);
		}
		cout << endl << endl;
	}

	{
		// nth_element
		shuffle(v.begin(), v.end(), dre);				// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		cout << "nth_element 결과" << endl;
		cout << endl;
		nth_element(v.begin(), v.begin() + 10, v.end());

		cout << "nth_element 통과" << endl;
		for (auto p = v.begin(); p != v.begin() + 10; ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl;

		cout << "nth_element 통과하지 못함" << endl;
		for (auto p = v.begin() + 10 ; p != v.end(); ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl << endl;
	}
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:54:17
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms	- sort 관련 함수들
// partition	- 기준에 따라 분리
// nth_element	- 기준에 맞는 n개를 분리
// partial_sotr	- n개까지만 정렬
// sort			- 기준에 따라 모든 원소를 정렬 
// stable_sort	- 상대적인 순서를 변경하지 않으면서 모든 원소를 정렬
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <format>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

default_random_engine dre;

//--------
int main()
//--------
{
	save("소스.cpp");

	// 자료 준비
	vector<int> v(100);
	for (int i = 0; i < 100; ++i) {
		v[i] = i + 1;
	}

	{
		// partition - odd / even
		shuffle(v.begin(), v.end(), dre);				// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		auto p = partition(v.begin(), v.end(), [](int n) { return n % 2 == 1; });
		cout << "partition 결과" << endl;
		cout << endl;
		cout << "odd numbers" << endl;
		for (auto i = v.begin(); i != p; ++i) {
			cout << format("{:4}", *i);
		}
		cout << endl;
		cout << "even numbers" << endl;
		for (auto i = p; i != v.end(); ++i) {
			cout << format("{:4}", *i);
		}
		cout << endl << endl;
	}

	{
		// nth_element
		shuffle(v.begin(), v.end(), dre);				// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		cout << "nth_element 결과" << endl;
		cout << endl;
		nth_element(v.begin(), v.begin() + 10, v.end());

		cout << "nth_element 통과" << endl;
		for (auto p = v.begin(); p != v.begin() + 30; ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl;

		cout << "nth_element 통과하지 못함" << endl;
		for (auto p = v.begin() + 30 ; p != v.end(); ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl << endl;
	}
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:57:51
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms	- sort 관련 함수들
// partition	- 기준에 따라 분리
// nth_element	- 기준에 맞는 n개를 분리
// partial_sotr	- n개까지만 정렬
// sort			- 기준에 따라 모든 원소를 정렬 
// stable_sort	- 상대적인 순서를 변경하지 않으면서 모든 원소를 정렬
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <format>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

default_random_engine dre;

//--------
int main()
//--------
{
	save("소스.cpp");

	// 자료 준비
	vector<int> v(100);
	for (int i = 0; i < 100; ++i) {
		v[i] = i + 1;
	}

	{
		// partition - odd / even
		shuffle(v.begin(), v.end(), dre);				// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		auto p = partition(v.begin(), v.end(), [](int n) { return n % 2 == 1; });
		cout << "partition 결과" << endl;
		cout << endl;
		cout << "odd numbers" << endl;
		for (auto i = v.begin(); i != p; ++i) {
			cout << format("{:4}", *i);
		}
		cout << endl;
		cout << "even numbers" << endl;
		for (auto i = p; i != v.end(); ++i) {
			cout << format("{:4}", *i);
		}
		cout << endl << endl;
	}

	{
		// nth_element
		shuffle(v.begin(), v.end(), dre);				// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		cout << "nth_element 결과" << endl;
		cout << endl;
		nth_element(v.begin(), v.begin() + 10, v.end());

		cout << "nth_element 통과" << endl;
		for (auto p = v.begin(); p != v.begin() + 10; ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl;

		cout << "nth_element 통과하지 못함" << endl;
		for (auto p = v.begin() + 10 ; p != v.end(); ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl << endl;
	}

	{
		// partial_sort
		shuffle(v.begin(), v.end(), dre);				// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		cout << "partial_sort 30개까지 정렬한 결과" << endl;
		cout << endl;
		partial_sort(v.begin(), v.begin() + 30, v.end());

		cout << "정렬된 30개" << endl;
		for (auto p = v.begin(); p != v.begin() + 30; ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl;

		cout << "나머지 70개" << endl;
		for (auto p = v.begin() + 30; p != v.end(); ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl << endl;
	}
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 10:59:55
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms	- sort 관련 함수들
// partition	- 기준에 따라 분리
// nth_element	- 기준에 맞는 n개를 분리
// partial_sotr	- n개까지만 정렬
// sort			- 기준에 따라 모든 원소를 정렬 
// stable_sort	- 상대적인 순서를 변경하지 않으면서 모든 원소를 정렬
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <format>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

default_random_engine dre;

//--------
int main()
//--------
{
	save("소스.cpp");

	// 자료 준비
	vector<int> v(100);
	for (int i = 0; i < 100; ++i) {
		v[i] = i + 1;
	}

	{
		// partition - odd / even
		shuffle(v.begin(), v.end(), dre);				// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		auto p = partition(v.begin(), v.end(), [](int n) { return n % 2 == 1; });
		cout << "partition 결과" << endl;
		cout << endl;
		cout << "odd numbers" << endl;
		for (auto i = v.begin(); i != p; ++i) {
			cout << format("{:4}", *i);
		}
		cout << endl;
		cout << "even numbers" << endl;
		for (auto i = p; i != v.end(); ++i) {
			cout << format("{:4}", *i);
		}
		cout << endl << endl;
	}

	{
		// nth_element
		shuffle(v.begin(), v.end(), dre);				// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		cout << "nth_element 결과" << endl;
		cout << endl;
		nth_element(v.begin(), v.begin() + 10, v.end());

		cout << "nth_element 통과" << endl;
		for (auto p = v.begin(); p != v.begin() + 10; ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl;

		cout << "nth_element 통과하지 못함" << endl;
		for (auto p = v.begin() + 10 ; p != v.end(); ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl << endl;
	}

	{
		// partial_sort
		shuffle(v.begin(), v.end(), dre);				// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		cout << "partial_sort 30개까지 정렬한 결과" << endl;
		cout << endl;
		partial_sort(v.begin(), v.begin() + 30, v.end());

		cout << "정렬된 30개" << endl;
		for (auto p = v.begin(); p != v.begin() + 30; ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl;

		cout << "나머지 70개" << endl;
		for (auto p = v.begin() + 30; p != v.end(); ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl << endl;
	}

	{
		// sort
		shuffle(v.begin(), v.end(), dre);				// 자료를 섞는다
		for (int n : v) {
			cout << format("{:4}", n);
		}
		cout << endl << endl;

		cout << "정렬한 결과" << endl;
		cout << endl;
		sort(v.begin(), v.end());
		for (auto p = v.begin(); p != v.end(); ++p) {
			cout << format("{:4}", *p);
		}
		cout << endl << endl;
	}
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 11:53:44
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms	- sort 관련 함수들
// partition	- 기준에 따라 분리
// nth_element	- 기준에 맞는 n개를 분리
// partial_sotr	- n개까지만 정렬
// sort			- 기준에 따라 모든 원소를 정렬 
// stable_sort	- 상대적인 순서를 변경하지 않으면서 모든 원소를 정렬
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <format>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{ 1, 50 };
uniform_int_distribution<int> uidChar{ 'a', 'z' };

struct Dog {
	int num;
	char c;

	Dog() {
		num = uid(dre);
		c = uidChar(dre);
	}
};

//--------
int main()
//--------
{
	save("소스.cpp");
	
	// 자료 준비
	vector<Dog> dogs(100);

	for (const Dog& dog : dogs) {
		cout << dog.c << " - " << dog.num << endl;
	}
}


======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 11:56:10
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms	- sort 관련 함수들
// partition	- 기준에 따라 분리
// nth_element	- 기준에 맞는 n개를 분리
// partial_sotr	- n개까지만 정렬
// sort			- 기준에 따라 모든 원소를 정렬 
// stable_sort	- 상대적인 순서를 변경하지 않으면서 모든 원소를 정렬
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <format>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{ 1, 20 };
uniform_int_distribution<int> uidChar{ 'a', 'z' };

struct Dog {
	int num;
	char c;

	Dog() {
		num = uid(dre);
		c = uidChar(dre);
	}
};

//--------
int main()
//--------
{
	save("소스.cpp");
	
	// 자료 준비
	vector<Dog> dogs(100);

	sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.c < b.c;
		});

	for (const Dog& dog : dogs) {
		cout << dog.c << " - " << dog.num << endl;
	}
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 11:57:29
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms	- sort 관련 함수들
// partition	- 기준에 따라 분리
// nth_element	- 기준에 맞는 n개를 분리
// partial_sotr	- n개까지만 정렬
// sort			- 기준에 따라 모든 원소를 정렬 
// stable_sort	- 상대적인 순서를 변경하지 않으면서 모든 원소를 정렬
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <format>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{ 1, 20 };
uniform_int_distribution<int> uidChar{ 'a', 'z' };

struct Dog {
	int num;
	char c;

	Dog() {
		num = uid(dre);
		c = uidChar(dre);
	}
};

//--------
int main()
//--------
{
	save("소스.cpp");
	
	// 자료 준비
	vector<Dog> dogs(100);
	
	// 글자 c 기준 정렬
	sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.c < b.c;
		});

	// 숫자 num 기준 정렬
	sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.num < b.num;
		});

	for (const Dog& dog : dogs) {
		cout << dog.c << " - " << dog.num << endl;
	}
}

======================================================
소스.cpp, 저장시간: 2023-05-31 수요일 오후 11:59:03
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// algorithms	- sort 관련 함수들
// partition	- 기준에 따라 분리
// nth_element	- 기준에 맞는 n개를 분리
// partial_sotr	- n개까지만 정렬
// sort			- 기준에 따라 모든 원소를 정렬 
// stable_sort	- 상대적인 순서를 변경하지 않으면서 모든 원소를 정렬
//====================================================================
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <format>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uid{ 1, 20 };
uniform_int_distribution<int> uidChar{ 'a', 'z' };

struct Dog {
	int num;
	char c;

	Dog() {
		num = uid(dre);
		c = uidChar(dre);
	}
};

//--------
int main()
//--------
{
	save("소스.cpp");
	
	// 자료 준비
	vector<Dog> dogs(100);
	
	// 글자 c 기준 정렬
	sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.c < b.c;
		});

	// 숫자 num 기준 정렬 - 글자 c 기준으로 정렬한 순서를 지키면서
	stable_sort(dogs.begin(), dogs.end(), [](const Dog& a, const Dog& b) {
		return a.num < b.num;
		});

	for (const Dog& dog : dogs) {
		cout << dog.c << " - " << dog.num << endl;
	}
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오전 12:04:54
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	save("소스.cpp");
	
	vector<int> v{ 1,2,3,4,5 };

	cout << distance(v.begin(), v.end()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오전 12:05:14
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	save("소스.cpp");
	
	vector<int> v{ 1,2,3,4,5 };

	cout << distance(v.end(), v.begin()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오전 12:06:44
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	save("소스.cpp");
	
	set<int> s{ 1,2,3,4,5 };

	cout << distance(s.begin(), s.end()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오전 12:08:14
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	save("소스.cpp");
	
	set<int> s{ 1,2,3,4,5 };

	cout << distance(s.end(), s.begin()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오전 12:08:29
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	save("소스.cpp");
	
	list<int> s{ 1,2,3,4,5 };

	cout << distance(s.end(), s.begin()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오전 12:11:24
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e) 
{
	int cnt{};
	while (b != e) {
		++b;
		++cnt;
	}
	return cnt;
}

//--------
int main()
//--------
{
	save("소스.cpp");
	
	list<int> s{ 1,2,3,4,5 };

	cout << my_distance(s.begin(), s.end()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오전 12:11:43
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e) 
{
	int cnt{};
	while (b != e) {
		++b;
		++cnt;
	}
	return cnt;
}

//--------
int main()
//--------
{
	save("소스.cpp");
	
	list<int> s{ 1,2,3,4,5 };

	cout << my_distance(s.end(), s.begin()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오전 12:12:14
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <forward_list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e) 
{
	int cnt{};
	while (b != e) {
		++b;
		++cnt;
	}
	return cnt;
}

//--------
int main()
//--------
{
	save("소스.cpp");
	
	forward_list<int> s{ 1,2,3,4,5 };

	cout << my_distance(s.end(), s.begin()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오전 12:14:12
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <forward_list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e) 
{
	int cnt{};
	while (b != e) {
		++b;
		++cnt;
	}
	return cnt;
}

//--------
int main()
//--------
{
	save("소스.cpp");
	
	vector<int> v{ 1,2,3,4,5 };

	cout << my_distance(v.end(), v.begin()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오전 12:15:15
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <forward_list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e) 
{
	return e - b;
}

//--------
int main()
//--------
{
	save("소스.cpp");
	
	vector<int> v{ 1,2,3,4,5 };

	cout << my_distance(v.end(), v.begin()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오전 12:15:29
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <forward_list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e) 
{
	return e - b;
}

//--------
int main()
//--------
{
	save("소스.cpp");
	
	vector<int> v{ 1,2,3,4,5 };

	cout << my_distance(v.begin(), v.end()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 1:43:18
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
// tag dispatching
// concept
//====================================================================
#include <iostream>
#include <set>
#include <algorithm>
#include <forward_list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e)
{
	int step{};

	while (b != e) {
		++step;
		++b;
	}
	return step;
}

//--------
int main()
//--------
{
	save("소스.cpp");	
	
	set<int> s{ 1,2,3,4,5 };

	cout << my_distance(s.begin(), s.end()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 1:47:25
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
// tag dispatching
// concept
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <forward_list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e)
{
	// Iter가 적어도 forward_iterator라면
	int step{};

	while (b != e) {
		++step;
		++b;
	}
	return step;
}

//--------
int main()
//--------
{
	save("소스.cpp");	
	
	vector<int> s{ 1,2,3,4,5 };

	cout << my_distance(s.begin(), s.end()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 2:02:09
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
// tag dispatching
// constexpr specifier
// concept
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <forward_list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e)
{
	// 만일 Iter가 random_access_iterator_tag라면
	if (typeid(iterator_traits<Iter>::iterator_category) == typeid(random_access_iterator_tag)) {
		cout << "random access iterator가 전달되었다." << endl;
		return e - b;
	}
	
	// Iter가 적어도 forward_iterator라면
	int step{};

	while (b != e) {
		++step;
		++b;
	}
	return step;
}

//--------
int main()
//--------
{
	save("소스.cpp");	
	
	vector<int> s{ 1,2,3,4,5 };

	cout << my_distance(s.end(), s.begin()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 2:09:57
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
// tag dispatching
// constexpr specifier
// concept
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e)
{
	// 전달된 타입 T의 여분의 정보를 알아보기 위한 수단 - type_traits

	// 만일 Iter가 random_access_iterator_tag라면
	if (typeid(iterator_traits<Iter>::iterator_category) == typeid(random_access_iterator_tag)) {
		cout << "random access iterator가 전달되었다." << endl;
		return e - b;
	}
	
	// Iter가 적어도 forward_iterator라면
	int step{};

	while (b != e) {
		++step;
		++b;
	}
	return step;
}

//--------
int main()
//--------
{
	save("소스.cpp");	
	
	list<int> l{1, 2, 3, 4, 5};

	cout << distance(l.begin(), l.end()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 2:11:22
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현
// tag dispatching
// constexpr specifier
// concept
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e)
{
	// 전달된 타입 T의 여분의 정보를 알아보기 위한 수단 - type_traits

	// 만일 Iter가 random_access_iterator_tag라면
	if (typeid(iterator_traits<Iter>::iterator_category) == typeid(random_access_iterator_tag)) {
		cout << "random access iterator가 전달되었다." << endl;
		return e - b;
	}
	
	// Iter가 적어도 forward_iterator라면
	int step{};

	while (b != e) {
		++step;
		++b;
	}
	return step;
}

//--------
int main()
//--------
{
	save("소스.cpp");	
	
	list<int> l{1, 2, 3, 4, 5};

	cout << distance(l.end(), l.begin()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 2:22:07
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현	- iterator operation
// tag dispatching	- C++17 이전에 적합한 함수를 호출하는 기법
// constexpr if		- 소스코드를 선택적으로 확장
// concept
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e) 
{
	// 만일 Iter가 random_access_iterator_tag라면
	if constexpr (typeid(iterator_traits<Iter>::iterator_category) == typeid(random_access_iterator_tag)) {
		cout << "random access iterator가 전달되었다." << endl;
		return e - b;
	}

	// Iter가 적어도 forward_iterator라면
	int step{};

	while (b != e) {
		++step;
		++b;
	}
	return step;
}

//--------
int main()
//--------
{
	save("소스.cpp");	
	
	list<int> l{1, 2, 3, 4, 5};

	cout << my_distance(l.begin(), l.end()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 2:22:16
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현	- iterator operation
// tag dispatching	- C++17 이전에 적합한 함수를 호출하는 기법
// constexpr if		- 소스코드를 선택적으로 확장
// concept
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e) 
{
	// 만일 Iter가 random_access_iterator_tag라면
	if constexpr (typeid(iterator_traits<Iter>::iterator_category) == typeid(random_access_iterator_tag)) {
		cout << "random access iterator가 전달되었다." << endl;
		return e - b;
	}

	// Iter가 적어도 forward_iterator라면
	int step{};

	while (b != e) {
		++step;
		++b;
	}
	return step;
}

//--------
int main()
//--------
{
	save("소스.cpp");	
	
	list<int> l{1, 2, 3, 4, 5};

	cout << my_distance(l.end(), l.begin()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 2:22:35
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현	- iterator operation
// tag dispatching	- C++17 이전에 적합한 함수를 호출하는 기법
// constexpr if		- 소스코드를 선택적으로 확장
// concept
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e) 
{
	// 만일 Iter가 random_access_iterator_tag라면
	if constexpr (typeid(iterator_traits<Iter>::iterator_category) == typeid(random_access_iterator_tag)) {
		cout << "random access iterator가 전달되었다." << endl;
		return e - b;
	}

	// Iter가 적어도 forward_iterator라면
	int step{};

	while (b != e) {
		++step;
		++b;
	}
	return step;
}

//--------
int main()
//--------
{
	save("소스.cpp");	
	
	vector<int> l{1, 2, 3, 4, 5};

	cout << my_distance(l.end(), l.begin()) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 2:38:41
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현	- iterator operation
// tag dispatching	- C++17 이전에 적합한 함수를 호출하는 기법
// constexpr if		- 소스코드를 선택적으로 확장
// concept
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class Iter>
int my_distance(Iter b, Iter e) 
{
	// 만일 Iter가 random_access_iterator_tag라면
	if constexpr (typeid(iterator_traits<Iter>::iterator_category) == typeid(random_access_iterator_tag)) {
		cout << "random access iterator가 전달되었다." << endl;
		return e - b;
	}

	// Iter가 적어도 forward_iterator라면
	int step{};

	while (b != e) {
		++step;
		++b;
	}
	return step;
}

int add(int a, int b) {
	return a + b;
}

double add(double a, double b) {
	return a + b;
}

//--------
int main()
//--------
{
	save("소스.cpp");	
	
	cout << add(3, 4) << endl;
	cout << add(3.3, 4.4) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 2:41:44
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// distance 구현	- iterator operation
// tag dispatching	- C++17 이전에 적합한 함수를 호출하는 기법
// constexpr if		- 소스코드를 선택적으로 확장
// concept
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class T>
T add(T a, T b)
{
	return a + b;
}

//--------
int main()
//--------
{
	save("소스.cpp");	
	
	cout << add(3, 4) << endl;
	cout << add(3.3, 4.4) << endl;
	cout << add(String{ "123" }, String{ "456" }) << endl;
}

// is_integral == type_traits
// integral == concept

template<integral T>
T add(T a, T b)
{
	return a + b;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 3:04:53
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// C++20 - 4 major change
// Concept
// Range
// Module
// Coroutine
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class T>
concept 정수와플로트만 = integral<T> or floating_point<T>;

template<정수와플로트만 T>
T add(T a, T b)
{
	return a + b;
}

class Dog {
	friend std::ostream& operator <<(std::ostream& os, const Dog& dog) {
		return os;
	}
};

//--------
int main()
//--------
{
	save("소스.cpp");	
	
	cout << add(3, 4) << endl;
	cout << add(3.3, 4.4) << endl;
	//cout << add(String{ "123" }, String{ "456" }) << endl;
	//cout << add(Dog{}, Dog{}) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 3:06:36
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// C++20 - 4 major change
// Concept
// Range
// Module
// Coroutine
//====================================================================
#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

template<class T>
concept addable = integral<T> or floating_point<T>;


addable auto add(addable auto a, addable auto b)
{
	return a + b;
}

class Dog {
	friend std::ostream& operator <<(std::ostream& os, const Dog& dog) {
		return os;
	}
};

//--------
int main()
//--------
{
	save("소스.cpp");	
	
	cout << add(3, 4) << endl;
	cout << add(3.3, 4.4) << endl;
	//cout << add(String{ "123" }, String{ "456" }) << endl;
	//cout << add(Dog{}, Dog{}) << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-01 목요일 오후 3:18:46
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (13주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// C++20 - 4 major change
// Concept
// Range
// Module
// Coroutine
//====================================================================
#include <iostream>
#include <ranges>
#include <algorithm>
#include <random>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

default_random_engine dre;
uniform_int_distribution uidNum{ 1,100 };
uniform_int_distribution<int> uidChar{'a', 'z'};

struct Dog
{
	int n;
	char c;

	Dog() {
		n = uidNum(dre);
		c = uidChar(dre);
	}
};

//--------
int main()
//--------
{
	save("소스.cpp");	

	vector<Dog> dogs(100);
	
	ranges::sort(dogs, {}, &Dog::c);

	for (auto [숫자, 글자] : dogs) {
		cout << 글자 << " - " << 숫자 << endl;
	}
}

======================================================
소스.cpp, 저장시간: 2023-06-05 월요일 오후 2:09:55
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 6. 6일 업로드할 동영상 - 총정리 실습
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미 (sementic)를
//			 만족하는지 컴파일 타임에 검사(소스코드 확장 전);
// Range   - composable / less error-prone -> lazy evaluation(지연 평가)
// - [begin, end]
// -
// -
// -
//====================================================================
#include <iostream>
#include <ranges>
#include <algorithm>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v{ 3,8,6,1,2,9,4,10,7,5 };

	ranges::sort(v);

	for (int n : views::counted(&v[1], 5)) {
		std::cout << n << ' ';
	}
	std::cout << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-05 월요일 오후 2:10:06
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 6. 6일 업로드할 동영상 - 총정리 실습
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미 (sementic)를
//			 만족하는지 컴파일 타임에 검사(소스코드 확장 전);
// Range   - composable / less error-prone -> lazy evaluation(지연 평가)
// - [begin, end]
// -
// -
// -
//====================================================================
#include <iostream>
#include <ranges>
#include <algorithm>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v{ 3,8,6,1,2,9,4,10,7,5 };

	ranges::sort(views::counted(&v[1], 5));

	for (int n : views::counted(&v[1], 5)) {
		std::cout << n << ' ';
	}
	std::cout << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-05 월요일 오후 2:11:48
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 6. 6일 업로드할 동영상 - 총정리 실습
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미 (sementic)를
//			 만족하는지 컴파일 타임에 검사(소스코드 확장 전);
// Range   - composable / less error-prone -> lazy evaluation(지연 평가)
// - [begin, end]
// -
// -
// -
//====================================================================
#include <iostream>
#include <ranges>
#include <algorithm>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v{ 3,8,6,1,2,9,4,10,7,5 };

	ranges::sort(views::counted(v.begin() + 1, 5));

	for (int n : views::counted(&v[1], 5)) {
		std::cout << n << ' ';
	}
	std::cout << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-05 월요일 오후 2:14:56
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 6. 6일 업로드할 동영상 - 총정리 실습
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미 (sementic)를
//			 만족하는지 컴파일 타임에 검사(소스코드 확장 전);
// Range   - composable / less error-prone -> lazy evaluation(지연 평가)
// - [begin, end)
// - [start, size)
// - [start, predicate)
// - [start..)
//====================================================================
#include <iostream>
#include <ranges>
#include <algorithm>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v{ 3,8,6,1,2,9,4,10,7,5 };

	ranges::sort(v);

	for (int n : views::take_while(v, [](int n) {return n < 5; })) {
		std::cout << n << ' ';
	}
	std::cout << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-05 월요일 오후 2:17:08
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 6. 6일 업로드할 동영상 - 총정리 실습
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미 (sementic)를
//			 만족하는지 컴파일 타임에 검사(소스코드 확장 전);
// Range   - composable / less error-prone -> lazy evaluation(지연 평가)
// - [begin, end)
// - [start, size)
// - [start, predicate)
// - [start..)
//====================================================================
#include <iostream>
#include <ranges>
#include <algorithm>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v{ 3,8,6,1,2,9,4,10,7,5 };

	ranges::sort(views::take_while(v, [](int n) {return n < 5; }));

	for (int n : v) {
		std::cout << n << ' ';
	}
	std::cout << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-05 월요일 오후 2:35:47
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 6. 6일 업로드할 동영상 - 총정리 실습
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미 (sementic)를
//			 만족하는지 컴파일 타임에 검사(소스코드 확장 전);
// Range   - composable / less error-prone -> lazy evaluation(지연 평가)
// - [begin, end)
// - [start, size)
// - [start, predicate)
// - [start..)
//====================================================================
#include <iostream>
#include <ranges>
#include <algorithm>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	// 이건 range는 아님
	for (int n : {1,2,3,4,5,6,7}) {
		std::cout << n << ' ';
	}
	std::cout << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-05 월요일 오후 2:37:37
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 6. 6일 업로드할 동영상 - 총정리 실습
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미 (sementic)를
//			 만족하는지 컴파일 타임에 검사(소스코드 확장 전);
// Range   - composable / less error-prone -> lazy evaluation(지연 평가)
// - [begin, end)
// - [start, size)
// - [start, predicate)
// - [start..)
//====================================================================
#include <iostream>
#include <ranges>
#include <algorithm>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;


//--------
int main()
//--------
{
	vector<int> v{ 1,2,3,4,5 };
	
	auto 범위 = views::counted(v.begin(), 3);

	cout << 범위.size();

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-05 월요일 오후 2:53:55
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 6. 6일 업로드할 동영상 - 총정리 실습
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미 (sementic)를
//			 만족하는지 컴파일 타임에 검사(소스코드 확장 전);
// Range   - composable / less error-prone -> lazy evaluation(지연 평가)
// - [begin, end)
// - [start, size)
// - [start, predicate)
// - [start..)
//====================================================================
#include <iostream>
#include <ranges>
#include <algorithm>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

bool isPrime2(int number)
{
	for (int i = 2; i < number; i++)
		if (number % i == 0)
			return false;
	return true;
}

//--------
int main()
//--------
{
	// 소수(prime number)를 영원히 출력하라
	// 100만 이상의 수 중에서 100개만 출력하라

	auto 백만이하 = [](int n) {return n <= 100'0000; };

	for (int n : views::iota(2) 
		| views::drop_while(백만이하)
		| views::filter(isPrime2)
		| views::take(100)
		) {
		cout << n << ' ';
	}

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-05 월요일 오후 2:56:11
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 6. 6일 업로드할 동영상 - 총정리 실습
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// C++20 - 4 major change
// Concept - 템플릿에 전달되는 인자(자료형)가 원하는 의미 (sementic)를
//			 만족하는지 컴파일 타임에 검사(소스코드 확장 전);
// Range   - composable / less error-prone -> lazy evaluation(지연 평가)
// - [begin, end)
// - [start, size)
// - [start, predicate)
// - [start..)
//====================================================================
#include <iostream>
#include <ranges>
#include <algorithm>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

bool isPrime2(int number)
{
	for (int i = 2; i < number; i++)
		if (number % i == 0)
			return false;
	return true;
}

//--------
int main()
//--------
{
	// 소수(prime number)를 영원히 출력하라
	// 100만 이상의 수 중에서 100개만 뒤에서부터 출력하라

	auto 백만이하 = [](int n) {return n <= 100'0000; };

	for (int n : views::iota(2) 
		| views::drop_while(백만이하)
		| views::filter(isPrime2)
		| views::take(100)
		| views::reverse
		) {
		cout << n << ' ';
	}

	save("소스.cpp");	
}


======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오전 2:37:26
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다	: 369882 단어가 있다.
// - 진짜 정렬되어 있나?			: 그렇다.
// - 중복된 단어는?					: 없다.
// - 길이가 가장 긴 단어는?			: dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
	PS(string s) : pair(s, s) {
		sort(first.begin(), first.end());
	}
};

//--------
int main()
//--------
{
	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일에 문제가 있다";
		exit(0);
	}

	PS dog{ "dog" };
	cout << dog.first << ", " << dog.second << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오전 2:39:27
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다	: 369882 단어가 있다.
// - 진짜 정렬되어 있나?			: 그렇다.
// - 중복된 단어는?					: 없다.
// - 길이가 가장 긴 단어는?			: dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
	PS(string s) : pair(s, s) {
		sort(first.begin(), first.end());
	}
};

//--------
int main()
//--------
{
	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일에 문제가 있다";
		exit(0);
	}

	vector<PS> v;
	v.reserve(400000);

	string s;
	while (in >> s) {
		v.push_back(s);
	}
	cout << "단어 개수: " << v.size() << endl;


	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오전 2:42:29
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다	: 369882 단어가 있다.
// - 진짜 정렬되어 있나?			: 그렇다.
// - 중복된 단어는?					: 없다.
// - 길이가 가장 긴 단어는?			: dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
	PS(string s) : pair(s, s) {
		sort(first.begin(), first.end());
	}
};

//--------
int main()
//--------
{
	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일에 문제가 있다";
		exit(0);
	}

	vector<PS> v;
	v.reserve(400000);

	string s;
	while (in >> s) {
		v.push_back(s);
	}
	cout << "단어 개수: " << v.size() << endl;

	// v의 일부분을 출력한다
	// 입력한 수 부터 100개
	cout << "어디서부터 출력할까요?: ";
	int num;
	cin >> num;
	for (const auto& [정렬, 원본] : v | views::drop(num) | views::take(100)) {
		cout << 정렬 << " - " << 원본 << endl;
	}

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오전 2:44:27
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다	: 369882 단어가 있다.
// - 진짜 정렬되어 있나?			: 그렇다.
// - 중복된 단어는?					: 없다.
// - 길이가 가장 긴 단어는?			: dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
	PS(string s) : pair(s, s) {
		sort(first.begin(), first.end());
	}
};

//--------
int main()
//--------
{
	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일에 문제가 있다";
		exit(0);
	}

	vector<PS> v;
	v.reserve(400000);

	string s;
	while (in >> s) {
		v.push_back(s);
	}
	cout << "단어 개수: " << v.size() << endl;

	// v를 first 오름차순으로 정렬한다.
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
		});

	// v의 일부분을 출력한다
	// 입력한 수 부터 100개
	cout << "어디서부터 출력할까요?: ";
	int num;
	cin >> num;
	for (const auto& [정렬, 원본] : v | views::drop(num) | views::take(100)) {
		cout << 정렬 << " - " << 원본 << endl;
	}

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오전 2:46:54
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다	: 369882 단어가 있다.
// - 진짜 정렬되어 있나?			: 그렇다.
// - 중복된 단어는?					: 없다.
// - 길이가 가장 긴 단어는?			: dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
	PS(string s) : pair(s, s) {
		sort(first.begin(), first.end());
	}
};

//--------
int main()
//--------
{
	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일에 문제가 있다";
		exit(0);
	}

	vector<PS> v;
	v.reserve(400000);

	string s;
	while (in >> s) {
		v.push_back(s);
	}
	cout << "단어 개수: " << v.size() << endl;

	// v를 first 오름차순으로 정렬한다.
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
		});

	// v의 일부분을 출력한다
	// 길이가 8글자인 경우만 100개
	cout << "어디서부터 출력할까요?: ";
	int num;
	cin >> num;
	for (const auto& [정렬, 원본] : v | views::drop(num) 
		| views::take_while([](const PS& ps) {return ps.first.size() == 8; })) {
		cout << 정렬 << " - " << 원본 << endl;
	}

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오전 2:51:38
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다	: 369882 단어가 있다.
// - 진짜 정렬되어 있나?			: 그렇다.
// - 중복된 단어는?					: 없다.
// - 길이가 가장 긴 단어는?			: dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
	PS(string s) : pair(s, s) {
		sort(first.begin(), first.end());
	}
};

//--------
int main()
//--------
{
	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일에 문제가 있다";
		exit(0);
	}

	vector<PS> v;
	v.reserve(400000);

	string s;
	while (in >> s) {
		v.push_back(s);
	}
	cout << "단어 개수: " << v.size() << endl;

	// v를 first 오름차순으로 정렬한다.
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
		});

	// v의 일부분을 출력한다
	// 길이가 8글자인 경우만 100개
	cout << "어디서부터 출력할까요?: ";
	int num;
	cin >> num;
	for (const auto& [정렬, 원본] : v | views::drop(num) 
		| views::filter([](const PS& ps) {return ps.first.size() == 8; })) {
		cout << 정렬 << " - " << 원본 << endl;
	}

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오전 2:52:22
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다	: 369882 단어가 있다.
// - 진짜 정렬되어 있나?			: 그렇다.
// - 중복된 단어는?					: 없다.
// - 길이가 가장 긴 단어는?			: dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
	PS(string s) : pair(s, s) {
		sort(first.begin(), first.end());
	}
};

//--------
int main()
//--------
{
	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일에 문제가 있다";
		exit(0);
	}

	vector<PS> v;
	v.reserve(400000);

	string s;
	while (in >> s) {
		v.push_back(s);
	}
	cout << "단어 개수: " << v.size() << endl;

	// v를 first 오름차순으로 정렬한다.
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
		});

	// v의 일부분을 출력한다
	// 길이가 8글자인 경우만 100개
	cout << "어디서부터 출력할까요?: ";
	int num;
	cin >> num;
	for (const auto& [정렬, 원본] : v 
		| views::drop(num) 
		| views::filter([](const PS& ps) {return ps.first.size() == 8; })
		| views::take(100)) {
		cout << 정렬 << " - " << 원본 << endl;
	}

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오전 2:54:52
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다	: 369882 단어가 있다.
// - 진짜 정렬되어 있나?			: 그렇다.
// - 중복된 단어는?					: 없다.
// - 길이가 가장 긴 단어는?			: dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
	PS(string s) : pair(s, s) {
		sort(first.begin(), first.end());
	}
};

//--------
int main()
//--------
{
	ifstream in{ "단어들.txt" };
	if (!in) {
		cout << "파일에 문제가 있다";
		exit(0);
	}

	vector<PS> v;
	v.reserve(400000);

	string s;
	while (in >> s) {
		v.push_back(s);
	}
	cout << "단어 개수: " << v.size() << endl;

	// v를 first 오름차순으로 정렬한다.
	sort(v.begin(), v.end(), [](const PS& a, const PS& b) {
		return a.first < b.first;
		});

	// v의 일부분을 출력한다
	// 길이가 8글자인 경우만 100개
	cout << "어디서부터 출력할까요?: ";
	int num;
	cin >> num;
	for (const auto& [정렬, 원본] : v 
		| views::drop(num) 
		| views::filter([](const PS& ps) {return ps.first.size() == 5; })
		| views::take(100)) {
		cout << 정렬 << " - " << 원본 << endl;
	}

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오후 2:29:51
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습
//====================================================================
#include <iostream>
#include <algorithm>
#include <random>
#include <array>
#include <numeric>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

array<int, 250'000'000> a;

default_random_engine dre;
uniform_int_distribution uid{0, 100};

//--------
int main()
//--------
{
	for (int& n : a) {
		n = uid(dre);
	}

	cout << "합계 게산 중...";
	long long sum = 0;
	for (int n : a) {
		sum += n;
	}
	cout << endl;
	cout << "합계: " << sum << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오후 2:32:38
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습
//====================================================================
#include <iostream>
#include <algorithm>
#include <random>
#include <array>
#include <numeric>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

array<int, 250'000'000> a;

default_random_engine dre;
uniform_int_distribution uid{0, 100};

//--------
int main()
//--------
{
	for (int& n : a) {
		n = uid(dre);
	}

	cout << "합계 게산 중...";
	long long sum = 0;

	auto b = chrono::steady_clock::now();

	for (int n : a) {
		sum += n;
	}

	auto d = chrono::steady_clock::now() - b;
	cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;
	cout << endl;
	cout << "합계: " << sum << endl;

	save("소스.cpp");	
}


======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오후 2:34:46
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습
//====================================================================
#include <iostream>
#include <algorithm>
#include <random>
#include <array>
#include <numeric>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

array<int, 250'000'000> a;

default_random_engine dre;
uniform_int_distribution uid{0, 100};

//--------
int main()
//--------
{
	for (int& n : a) {
		n = uid(dre);
	}

	cout << "합계 게산 중...";
	long long sum = 0;

	auto b = chrono::steady_clock::now();

	sum = accumulate(a.begin(), a.end(), 0);

	auto d = chrono::steady_clock::now() - b;
	cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;
	cout << endl;
	cout << "합계: " << sum << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오후 2:35:07
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습
//====================================================================
#include <iostream>
#include <algorithm>
#include <random>
#include <array>
#include <numeric>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

array<int, 250'000'000> a;

default_random_engine dre;
uniform_int_distribution uid{0, 100};

//--------
int main()
//--------
{
	for (int& n : a) {
		n = uid(dre);
	}

	cout << "합계 게산 중...";
	long long sum = 0;

	auto b = chrono::steady_clock::now();

	sum = accumulate(a.begin(), a.end(), 0);

	auto d = chrono::steady_clock::now() - b;
	cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;
	cout << endl;
	cout << "합계: " << sum << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오후 2:39:39
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습
//====================================================================
#include <iostream>
#include <algorithm>
#include <random>
#include <array>
#include <numeric>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

array<int, 250'000'000> a;

default_random_engine dre;
uniform_int_distribution uid{0, 100};

//--------
int main()
//--------
{
	for (int& n : a) {
		n = uid(dre);
	}

	cout << "합계 게산 중...";
	long long sum = 0;

	auto b = chrono::steady_clock::now();

	sum = reduce(a.begin(), a.end(), 0);

	auto d = chrono::steady_clock::now() - b;
	cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;
	cout << endl;
	cout << "합계: " << sum << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오후 2:40:06
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습
//====================================================================
#include <iostream>
#include <algorithm>
#include <random>
#include <array>
#include <numeric>
#include <thread>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

array<int, 250'000'000> a;

default_random_engine dre;
uniform_int_distribution uid{0, 100};

//--------
int main()
//--------
{
	for (int& n : a) {
		n = uid(dre);
	}

	cout << "합계 게산 중...";
	long long sum = 0;

	auto b = chrono::steady_clock::now();

	sum = reduce(a.begin(), a.end(), 0LL );

	auto d = chrono::steady_clock::now() - b;
	cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;
	cout << endl;
	cout << "합계: " << sum << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오후 2:43:03
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56							월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습
//====================================================================
#include <iostream>
#include <algorithm>
#include <random>
#include <array>
#include <numeric>
#include <thread>
#include <execution>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

array<int, 250'000'000> a;

default_random_engine dre;
uniform_int_distribution uid{0, 100};

//--------
int main()
//--------
{
	for (int& n : a) {
		n = uid(dre);
	}

	cout << "합계 게산 중...";
	long long sum = 0;

	auto b = chrono::steady_clock::now();

	sum = reduce(execution::par , a.begin(), a.end(), 0LL);

	auto d = chrono::steady_clock::now() - b;
	cout << "걸린 시간 - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;
	cout << endl;
	cout << "합계: " << sum << endl;

	save("소스.cpp");	
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오후 5:00:04
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56                     월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다   : 369882 단어가 있다.
// - 진짜 정렬되어 있나?            : 그렇다.
// - 중복된 단어는?                 : 없다.
// - 길이가 가장 긴 단어는?         : dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
    PS(string s) : pair(s, s) {
        sort(first.begin(), first.end());
    }
};

//--------
int main()
//--------
{
    ifstream in{ "단어들.txt" };
    if (!in) {
        cout << "파일에 문제가 있다";
        exit(0);
    }
    save("소스.cpp");

    vector<PS> v;
    v.reserve(400000);

    string s;
    while (in >> s) {
        v.push_back(s);
    }
    cout << "단어 개수: " << v.size() << endl;

    // v를 first 오름차순으로 정렬한다.
    auto PS기준 = [](const PS& a, const PS& b) {
        return a.first < b.first;
    };
    sort(v.begin(), v.end(), PS기준);

    // v의 일부분을 출력한다
    // 길이가 8글자인 경우만 100개
    //cout << "어디서부터 출력할까요?: ";
    //int num;
    //cin >> num;
    //for (const auto& [정렬, 원본] : v
    //    | views::drop(num)
    //    | views::filter([](const PS& ps) {return ps.first.size() == 5; })
    //    | views::take(100)) {
    //    cout << 정렬 << " - " << 원본 << endl;
    //}

    while (true) {
        cout << "찾을 단어를 입력하세요: ";
        string s;
        cin >> s;

        PS word{ s };

        auto [하한, 상한] = equal_range(v.begin(), v.end(), word, PS기준);
        if (하한 == 상한) {
            cout << "사전에 없는 단어 입니다." << endl;
            continue;
        }
        else {
            cout << s << "의 anagram 목록" << endl;
            for (auto p = 하한; p < 상한; ++p ) {
                cout << p->second << " ";
            }
            cout << endl;
        }
    }
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오후 11:24:31
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56                     월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다   : 369882 단어가 있다.
// - 진짜 정렬되어 있나?            : 그렇다.
// - 중복된 단어는?                 : 없다.
// - 길이가 가장 긴 단어는?         : dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
    PS(string s) : pair(s, s) {
        sort(first.begin(), first.end());
    }
};

//--------
int main()
//--------
{
    ifstream in{ "단어들.txt" };
    if (!in) {
        cout << "파일에 문제가 있다";
        exit(0);
    }
    save("소스.cpp");

    vector<PS> v;
    v.reserve(400000);

    string s;
    while (in >> s) {
        v.push_back(s);
    }
    cout << "단어 개수: " << v.size() << endl;

    // v를 first 오름차순으로 정렬한다.
    auto PS기준 = [](const PS& a, const PS& b) {
        return a.first < b.first;
    };
    sort(v.begin(), v.end(), PS기준);

    // [문제]전체 anagram 쌍을 화면에 출력하라.

    auto i = v.begin();
    while (true) {
        i = adjacent_find( i, v.end(), [](const PS& a, const PS& b) {
            return a.first == b.first;
            });
        if (i == v.end()) {
            break;
        }

        // 그렇다면 i와 i+1의 first는 같다
        auto j = find_if_not(i + 1, v.end(), [i](const PS& a) {
            return i->first == a.first;
            });

        // [i, j]는 anagram 쌍이다.
        for (auto k = i; k < j; ++k) {
            cout << k->second << ' ';
        }
        cout << endl;
        i = j;
    }
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오후 11:26:21
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56                     월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다   : 369882 단어가 있다.
// - 진짜 정렬되어 있나?            : 그렇다.
// - 중복된 단어는?                 : 없다.
// - 길이가 가장 긴 단어는?         : dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
    PS(string s) : pair(s, s) {
        sort(first.begin(), first.end());
    }
};

//--------
int main()
//--------
{
    ifstream in{ "단어들.txt" };
    if (!in) {
        cout << "파일에 문제가 있다";
        exit(0);
    }
    save("소스.cpp");

    vector<PS> v;
    v.reserve(400000);

    string s;
    while (in >> s) {
        v.push_back(s);
    }
    cout << "단어 개수: " << v.size() << endl;

    // v를 first 오름차순으로 정렬한다.
    auto PS기준 = [](const PS& a, const PS& b) {
        return a.first < b.first;
    };
    sort(v.begin(), v.end(), PS기준);

    // [문제]전체 anagram 쌍을 화면에 출력하라.

    auto i = v.begin();
    int cnt{};

    while (true) {
        i = adjacent_find( i, v.end(), [](const PS& a, const PS& b) {
            return a.first == b.first;
            });
        if (i == v.end()) {
            break;
        }

        // 그렇다면 i와 i+1의 first는 같다
        auto j = find_if_not(i + 1, v.end(), [i](const PS& a) {
            return i->first == a.first;
            });

        // [i, j]는 anagram 쌍이다.
        cout << "[" << ++cnt << "] - ";
        for (auto k = i; k < j; ++k) {
            cout << k->second << ' ';
        }
        cout << endl;
        i = j;
    }
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오후 11:31:20
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56                     월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다   : 369882 단어가 있다.
// - 진짜 정렬되어 있나?            : 그렇다.
// - 중복된 단어는?                 : 없다.
// - 길이가 가장 긴 단어는?         : dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
    PS(string s) : pair(s, s) {
        sort(first.begin(), first.end());
    }
};

//--------
int main()
//--------
{
    ifstream in{ "단어들.txt" };
    if (!in) {
        cout << "파일에 문제가 있다";
        exit(0);
    }
    save("소스.cpp");

    vector<PS> v;
    v.reserve(400000);

    string s;
    while (in >> s) {
        v.push_back(s);
    }
    cout << "단어 개수: " << v.size() << endl;

    // v를 first 오름차순으로 정렬한다.
    auto PS기준 = [](const PS& a, const PS& b) {
        return a.first < b.first;
    };
    sort(v.begin(), v.end(), PS기준);

    // [문제]전체 anagram 쌍을 컨테이너에 저장하라.
    vector<list<string>> anagrams;

    auto i = v.begin();
    int cnt{};

    while (true) {
        i = adjacent_find( i, v.end(), [](const PS& a, const PS& b) {
            return a.first == b.first;
            });
        if (i == v.end()) {
            break;
        }

        // 그렇다면 i와 i+1의 first는 같다
        auto j = find_if_not(i + 1, v.end(), [i](const PS& a) {
            return i->first == a.first;
            });

        // [i, j]는 anagram 쌍이다.
        list<string> con;
        for (auto k = i; k < j; ++k) {
            con.push_back(k->second);
        }
        anagrams.push_back(con);
        i = j;
    }
    cout << "모두 " << anagrams.size() << "개의 anagram 쌍을 찾았습니다." << endl;
}

======================================================
소스.cpp, 저장시간: 2023-06-08 목요일 오후 11:35:10
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56                     월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다   : 369882 단어가 있다.
// - 진짜 정렬되어 있나?            : 그렇다.
// - 중복된 단어는?                 : 없다.
// - 길이가 가장 긴 단어는?         : dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
    PS(string s) : pair(s, s) {
        sort(first.begin(), first.end());
    }
};

//--------
int main()
//--------
{
    ifstream in{ "단어들.txt" };
    if (!in) {
        cout << "파일에 문제가 있다";
        exit(0);
    }
    save("소스.cpp");

    vector<PS> v;
    v.reserve(400000);

    string s;
    while (in >> s) {
        v.push_back(s);
    }
    cout << "단어 개수: " << v.size() << endl;

    // v를 first 오름차순으로 정렬한다.
    auto PS기준 = [](const PS& a, const PS& b) {
        return a.first < b.first;
    };
    sort(v.begin(), v.end(), PS기준);

    // [문제]전체 anagram 쌍을 컨테이너에 저장하라.
    vector<list<string>> anagrams;

    auto i = v.begin();
    int cnt{};

    while (true) {
        i = adjacent_find( i, v.end(), [](const PS& a, const PS& b) {
            return a.first == b.first;
            });
        if (i == v.end()) {
            break;
        }

        // 그렇다면 i와 i+1의 first는 같다
        auto j = find_if_not(i + 1, v.end(), [i](const PS& a) {
            return i->first == a.first;
            });

        // [i, j]는 anagram 쌍이다.
        list<string> con;
        for (auto k = i; k < j; ++k) {
            con.push_back(k->second);
        }
        anagrams.push_back(con);
        i = j;
    }
    cout << "모두 " << anagrams.size() << "개의 anagram 쌍을 찾았습니다." << endl;

    // anagram 개수가 많은 순으로 정렬
    sort(anagrams.begin(), anagrams.end(), [](const list<string>& a, const list<string>& b) {
        return a.size() > b.size();
        });

    for (int i = 0; i < 10; ++i) {
        cout << anagrams[i].size() << " - ";
        for (const string& word : anagrams[i]) {
            cout << word << " ";
        }
        cout << endl;
    }
}

======================================================
소스.cpp, 저장시간: 2024-04-13 토요일 오전 12:11:59
======================================================

//====================================================================
// 2023. STL. 5월 22일 월56                     월56목56 (14주 2일)
// 15주 2일 6. 12 (월) - 기말 시험
//--------------------------------------------------------------------
// 2023 STL 총정리 실습 - 에너그램 찾기
// - "단어들.txt" 파일을 다운받는다.
// - 단어들을 컨테이너에 저장한다   : 369882 단어가 있다.
// - 진짜 정렬되어 있나?            : 그렇다.
// - 중복된 단어는?                 : 없다.
// - 길이가 가장 긴 단어는?         : dichlorodiphenyltrichloroethane(31)
// - 길이가 같은 단어 몇 개를 화면에 출력
// - 사용자가 입력한 단어가 사전에 있는지 검사
// - 사전에 있는 단어라면 anagram을 출력한다.
//====================================================================
#include <iostream>
#include <fstream>
#include <algorithm>
#include <ranges>
#include <vector>
#include <list>
#include "String.h"
#include "save.h"
using namespace std;
extern bool 관찰;

using std::string;

struct PS : pair<string, string>
{
    PS(string s) : pair(s, s) {
        sort(first.begin(), first.end());
    }
};

//--------
int main()
//--------
{
    // 안녕하새오
    save("소스.cpp");
}