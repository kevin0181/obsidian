//-----------------------------------------------------------------------------
// STL 중간시험
//-----------------------------------------------------------------------------
// 환경 - VS 17.12.4 이상, C++언어 표준 - /std:c++latest, 미리보기Release x64
// 헤더 파일을 추가할 필요는 없다.
// 각 문제에서 요구하는 답을 구분하여 적어라.	
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <memory>
#include <array>
#include <vector>
#include <algorithm>
#include <numeric>
#include <string>
using namespace std;


//-----------------------------------------------------------------------------
// Test는 num개의 int를 free-store에 확보한 contiguous 메모리에 저장한다.
//-----------------------------------------------------------------------------

class Test {
public:
	Test( ) = default;

	void show( ) const {
		cout << num << " - ";
		for ( int i = 0; i < 3; ++i )
			cout << p[ i ] << " ";
		cout << endl;
	}

private:
	int num {};					// free-store에 저장한 int의 개수	
	unique_ptr<int[]> p {};		// num개의 int가 저장되어 있는 contiguous 메모리를 관리하는 포인터

public:
	friend ostream& operator<<( ostream& os, const Test& t ) {
		os << t.num << " ";
		for ( int i = 0; i < t.num; ++i ) {
			os << t.p[ i ] << " ";
			if ( 0 == (i % 12)  )
				os << '\n';
		}
		return os;
	}

	friend istream& operator>>(istream& is, Test& t) {
		is >> t.num;
		t.p = std::make_unique<int[]>(t.num);
		for (int i = 0; i < t.num; ++i)
			is >> t.p[i];
		return is;
	}

	int max() const {
		return *std::max_element(p.get(), p.get() + num);
	}
};

//-----------------------------------------------------------------------------
// main에 있는 문제를 순서대로 해결하며 요구하는 답을 답지에 적어 제출한다.
//-----------------------------------------------------------------------------

//---------
int main( )
//---------
{
	ifstream in { "시험.dat" };
	if ( not in ) {
		cout << "파일을 열 수 없습니다" << endl;
		return 20250424;
	}

	//-------------------------------------------------------------------------
	// [문제 1] 파일 "시험.dat"에 저장된 Test 객체를 읽어 컨테이너에 저장하라.
	//-------------------------------------------------------------------------
	// "시험.dat" 파일은 text 모드로 열었다.
	// Test 객체는 << 연산자를 사용하여 기록하였다.
	// Test 객체가 몇 개인지는 파일을 읽어봐야 알 수 있는 상황이다.
	// 읽기 위해 추가한 내용을 답지에 적어라.
	// 모두 몇 개를 읽었는지 화면에 출력하고 답지에도 적어라. 
	//-------------------------------------------------------------------------
	// 답지에는 다음 내용을 적으면 된다.
	// - 사용한 컨테이너와 이유											(10)
	// - 읽기 위해 추가한 Test의 멤버함수와 관련 함수	 				(30+)
	// - 실제 읽어서 저장하는 코드										(10)
	// - 개수를 화면에 출력하는 코드와 출력된 내용						(10)
	//-------------------------------------------------------------------------


	std::vector<Test> tests; 
	Test temp;

	while (in >> temp) {
		tests.push_back(std::move(temp));
	}
	std::cout << "읽은 Test 객체 수: " << tests.size() << std::endl;
	//→ 이유 : 객체 개수를 알 수 없고, vector는 동적 크기를 지원하며 메모리가 contiguous하여 성능상 유리


	//-------------------------------------------------------------------------
	// [문제 2] 각 Test 객체에 저장된 int값 중에 가장 큰 값을 찾는 함수 max를 
	// 작성하라.
	//-------------------------------------------------------------------------
	// 답지에 함수 max의 정의를 적어라.									(10)
	//-------------------------------------------------------------------------
	// 다음과 같은 형식의 코드가 문제 없도록 하자.
	//-------------------------------------------------------------------------

	std::cout << "첫 Test 객체의 최댓값 - " << tests[0].max() << std::endl;

	// int 최대값 = 컨테이너[ 0 ].max( );

	// 이와 같은 형식으로 max를 사용한다
	// 이 코드에서 컨테이너는 [문제 1]에서 만든 컨테이너이다.


	// [ 문제 2 ]의 출력 예는 다음과 같다.
	//	첫 Test 객체의 최댓값 - 996461






	//-------------------------------------------------------------------------
	// [문제 3] [문제 2]에서 작성한 max()를 사용하면 컨테이너에 저장된 
	// 모든 Test 객체의 최댓값을 알 수 있다.
	// 각 Test 객체의 최댓값들을 저장하는 컨테이너를 새로 만들어 
	// 여기에 모든 Test 객체의 최댓값을 저장하라.						
	//-------------------------------------------------------------------------

	// 여기에 들어갈 코드를 답지에 적어라.								(10)		


	// [ 문제 3 ]의 출력 예는 다음과 같다
	// [문제 3]에서 만든 컨테이너에 저장된 최댓값들 - 앞에서 부터 10개만 출력
	// 996461 996135 981724 990110 993535 987983 978682 999080 974756 994505

	std::vector<int> maxValues;
	maxValues.reserve(tests.size());

	for (const Test& t : tests)
		maxValues.push_back(t.max());

	for (int i = 0; i < 10; ++i)
		std::cout << maxValues[i] << " ";
	std::cout << std::endl;




	//-------------------------------------------------------------------------
	// [문제 4] sort를 사용하여 [문제 3]의 컨테이너에 저장된 최댓값을 
	// 홀수와 짝수로 분리하라.
	// 컨테이너를 처음부터 순회할때 홀수가 먼저 나온 후에 짝수가 나와야 한다.
	//-------------------------------------------------------------------------

	// 여기에 들어갈 sort 코드를 답지에 적어라.							(10+)


	// [ 문제 4 ]의 출력 예는 다음과 같다
	// 컨테이너에 저장된 최댓값들을 홀수와 짝수로 분리 - 앞에서 부터 10개만 출력
	// 980999 995213 979767 797537 992907 986969 991953 971227 998041 996081

	std::ranges::sort(maxValues, [](int lhs, int rhs) {
		// 1. 홀수 우선
		bool l_odd = lhs % 2 == 1;
		bool r_odd = rhs % 2 == 1;

		if (l_odd != r_odd)
			return l_odd > r_odd; // 홀수가 true니까 먼저 오게

		// 2. 같은 부류면 내림차순
		return lhs > rhs;
		});


	std::cout << "------------------------" << std::endl;

	// 앞에서 10개 출력
	for (int i = 0; i < 10; ++i)
		std::cout << maxValues[i] << " ";
	std::cout << std::endl;


	//-------------------------------------------------------------------------
	// [문제 5] [문제 1]에서 만든 컨테이너에 저장된 Test 객체를 predicate을
	// 사용하지 않더라도 Test 객체의 최댓값 기준으로 오름차순 정렬되게 하고
	// 싶다. 
	// 어떻게 하면 되는 지 설명하라. (설명만 할 것)						(10)	 
	//-------------------------------------------------------------------------

	// sort( [문제 1]컨테이너.begin( ), [문제 1]컨테이너.end( ) );

	// 이와 같은 형식으로 코딩하면 최댓값 기준으로 오름차순 정렬되어야 한다.

	/*Test 객체에 대하여 operator< 연산자를 오버로드하면 된다.

		이 연산자에서 객체의 최댓값을 기준으로 비교하도록 정의하면,
		std::sort(tests.begin(), tests.end())처럼 비교 함수 없이 정렬해도
		최댓값 기준으로 오름차순 정렬이 된다.

		즉, Test 클래스 내부에서 operator<가 최댓값을 기준으로 작동하도록 만들면,
		별도의 predicate 없이도 sort 함수는 해당 기준으로 정렬하게 된다.*/

	//---------

	/*Test 객체의 max() 함수가 정의되어 있고, operator<를 오버로드하여
		다음과 같이 정의하면 된다 :

	bool operator<(const Test & rhs) const {
		return this->max() < rhs.max();
	}

	이렇게 하면 sort(tests.begin(), tests.end()) 만으로도 최댓값 기준 정렬이 가능하다.*/


	//-------------------------------------------------------------------------
	// [문제 6] [문제 5]의 sort가 충분히 빠르게 실행된다고 생각하는가?  
	// 더 빠르게 실행될 방법은 없는가?  
	// 이미 빠르다고 생각하거나 더 빠르게 할 방법이 있다면 이유를 설명하라.	(10)
	//-------------------------------------------------------------------------

	/*현재 sort는 객체마다 max()를 호출하므로, 하나의 Test 객체를 비교할 때마다 내부 배열을 순회하게 된다.
		이는 불필요한 반복 호출로 인해 전체 정렬 시 성능 저하를 일으킬 수 있다.

		성능을 더 높이기 위해서는 먼저 각 Test 객체의 max 값을 미리 구해 다른 컨테이너에 저장한 후,
		그 컨테이너를 정렬하는 것이 더 빠르다.

		즉, Test 객체의 max를 반복해서 호출하지 않고, 사전에 캐싱(cache)하면 속도를 높일 수 있다.*/



}